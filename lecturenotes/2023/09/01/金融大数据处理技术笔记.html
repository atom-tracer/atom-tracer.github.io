<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>金融大数据处理技术笔记 | Step far.</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="金融大数据处理技术笔记" />
<meta name="author" content="DragonK" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CH1 大数据 三次信息化浪潮 四种研究范式 大数据 定义 大数据意指一个超大的、难以用现有常规的数据库管理技术和工具 处理的数据集。 5V特征 Volume（大体量）：即可从数百TB到数十数百PB，甚至EB的规模 Variety（多样性）：即大数据包括各种格式和形态的数据 Velocity（时效性）：即很多大数据需要在一定的时间限度下得到及时处理 Veracity（准确性）：即处理的结果要保证一定的准确性 Value（大价值）：即大数据包含很多深度的价值，大数据分析挖掘和利用将带来巨大的商业价值 结构化/半结构化/非结构化 结构化数据：结构化数据是指在预定义的数据模型中组织的数据，通常存储在关系数据库中。它们有严格的格式和规则，例如行和列的表格。 半结构化数据：半结构化数据介于结构化数据和非结构化数据之间。它们没有严格的数据模型，但有某种形式的结构。例如JSON就是一个常见的数据格式，它有一些形式的规范（例如分隔），但可以存储数值，字符串等多种类型的元素。 非结构化数据：非结构化数据是没有特定结构的数据。这种数据类型包括文本、视频、音频、社交媒体发布等。 不同类型 大数据问题的特点和研究原则 基本特点 大数据来自应用行业，具有极强的行业应用需求特性 数据规模极大，达到PB甚至EB量级，超过任何传统数据库系统的处理能力 大数据处理给传统计算技术带来极大挑战，大多数传统算法在面向大数据处理时都面临问题，需要重写 基本原则 应用需求为导向：以行业应用问题和需求为出发点 领域交叉为桥梁：行业、IT产业、学术界协同 计算技术为支撑：研究解决涉及的计算技术问题 大数据的引擎 是软件，软件改变世界！ 大数据研究基本目标 以有效的信息技术手段和计算方法，获取、处理和分析各类应用行 业的大数据，发现和提取数据的内在价值，为行业提供高附加值的 应用和服务。 技术手段：信息技术和计算方法 核心目标：价值发现 效益目标：形成高附加值行业应用 大数据研究的挑战和基本途径 挑战 数据规模导致难以应付的存储量 数据规模导致传统算法失效 大数据复杂的数据关联性导致高复杂度的计算 基本途径 寻找新算法降低计算复杂度 降低大数据尺度，寻找数据尺度无关算法 大数据并行化处理 大数据典型和热点技术问题 大数据涉及的关键技术 金融大数据 金融数据：一般具有“流数据”特征，需要在短时间内快速处理。 具有逻辑关系紧密，处理实时性要求高，可展示性需求强等特征。 数据分析技术：数据挖掘，机器学习等AI技术 数据管理技术：关系型和非关系型数据管理、数据融合和集成技术、ETL等技术 数据处理技术：分布式计算，内存计算，流处理技术等 数据展示技术：可视化技术、历史流展示技术、空间信息流展示技术等。 CH2 并行计算技术 如何提高计算机性能？ 为什么要并行计算技术？为了提高计算机性能！ 提高处理器字长 提高集成度（限制：摩尔定律） 流水线等微体系结构技术 提高处理器频率 但是存在以下问题，导致单核处理器性能提升接近极限： VLSI集成度不可能无限制提高 处理器的指令级并行度提升接近极限（ILP墙） 处理器速度和存储器速度差异越来越大（CPU约为1ns，而主存约为100ns） 功耗和散热大幅增加超过芯片承受能力 并行计算技术的发展趋势和影响 越来越多的研究和应用领域需要使用并行计算技术 并行计算技术将渗透到每个计算应用领域，尤其是涉及到大规模数据和复杂计算的应用领域 并行计算技术将对传统计算技术产生革命性的影响 并行计算技术将影响传统计算技术的各个层面，与传统计算技术相互结合产生很多新的研究热点和课题 很多传统的串行算法和计算方法都将需要重新研究和设计其并行化算法和计算方法 并行计算技术的分类 弗林分类 并行类型分类 存储访问结构分类 系统类型分类 计算特征分类 并行程序设计模型/方法分类 发展趋势 并行计算主要技术问题 多核/多处理器网络互联结构技术 存储访问体系结构 分布式数据与文件管理 并行计算任务的分解与算法设计 并行程序设计模型和方法 数据同步访问和通信控制 可靠性设计与容错技术 并行计算软件框架平台 系统性能评估和程序并行度评估 MPI并行程序设计 MPI是什么？ MPI (Message Passing Interface)，基于消息传递的高性能并行计算编程接口。MPI在处理器间以消息传递方式进行数据通信和同步，以库函数形式为程序员提供了一组易于使用的编程接口。 特点：提供可靠的、面向消息的通信；在高性能科学计算领域广泛使用，适合于处理计算密集型的科学计算；独立于语言的编程规范，可移植性好。 MPI并行程序设计的时候需要注意什么？ 消息传递并行程序设计 用户必须通过显式地发送和接收消息来实现处理机间的数据交换。 每个并行进程均有自己独立的地址空间，相互之间访问不能直接进行，必须通过显式的消息传递来实现。 并行计算粒度大，特别适合于大规模可扩展并行算法 要求用户很好地分解问题，组织不同进程间的数据交换，并行计算粒度大。 MPI主要功能（通信方式） 用常规语言编程方式，所有节点运行同一个程序，但处理不同的数据 提供点对点通信(Point-point communication) 提供同步通信功能（阻塞通信） 提供异步通信功能（非阻塞通信） 提供节点集合通信(Collective communication) 提供一对多的广播通信 提供多节点计算同步控制 提供对结果的规约(Reduce)计算功能 提供用户自定义的复合数据类型传输 方式及相关接口整理如下： MPI提供三大类通信方式： 点对点通信 同步通信：阻塞式通信，等待通信操作完成后才返回。 MPI_Send (buf, count, datatype, dest, tag, comm) : 发送一个消息 MPI_Recv (buf, count, datatype, source, tag, comm, status) : 接受消息 异步通信：非阻塞式通信，不等待通信操作完成即返回。 MPI_ISend (buf, count, datatype, dest, tag, comm, request) : 异步发送 MPI_IRecv (buf, count, datatype, source, tag, comm, status, request) 异步接受消息 MPI_Wait (request, status) : 等待非阻塞数据传输完成 MPI_Test (request, flag, status) : 检查是否异步数据传输确实完成 节点集合通信 一对多的广播通信。主要有以下接口： MPI_BCAST: 一对多的广播式发送 多节点计算同步控制。主要有以下接口： MPI_GATHER：多个进程的消息以某种次序收集到一个进程 MPI_SCATTER：将一个信息划分为等长的段依次发送给其它进程 对结果的规约（Reduce）计算功能 MPI_Reduce：将一组进程的数据按照指定的操作方式规约到一起并传送给一个进程 用户自定义的复合数据类型传输 MPI程序 MPI基本程序结构 MPI并行程序设计接口 MPI编程示例 节点集合通信接口 提供一个进程与多个进程间同时通信的功能。 集合通信功能 数据规约操作 MPI特点和不足 MPI的特点 灵活性好，适合于各种计算密集型的并行计算任务 独立于语言的编程规范，可移植性好 有很多开放机构或厂商实现并支持 MPI的不足 无良好的数据和任务划分支持 缺少分布文件系统支持分布数据存储管理 通信开销大，当计算问题复杂、节点数量很大时，难以处理，性能大幅下降 无节点失效恢复机制，一旦有节点失效，可能导致计算过程无效 缺少良好的构架支撑，程序员需要考虑以上所有细节问题，程序设计较为复杂 CH3 MapReduce简介 MapReduce的基本模型和处理思想 三大设计思想 分而治之：处理大数据 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。 并行抽象模型：Mapper与Reducer MPI等并行计算方法缺少高层并行编程模型，为了克服这一缺陷，MapReduce借鉴了Lisp函数式语言中的思想，用Map和Reduce两个函数提供了高层的并行编程抽象模型。 统一构架，隐藏系统层细节 MPI等并行计算方法缺少统一的计算框架支持，程序员需要考虑数据存储、划分、分发、结果收集、错误恢复等诸多细节；为此，MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。 分而治之：处理大数据 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。 不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算！ 并行化计算示例： 概念： Master：负责划分和分配任务 Worker：负责数据块计算 构建抽象模型：Mapper与Reducer Map和Reduce的工作方式 MapReduce借鉴了函数式设计语言Lisp的设计思想。 Lisp定义了可对列表元素进行整体处理的各种操作，如： (add #(1 2 3 4) #(4 3 2 1)) 将产生结果： #(5 5 5 5) Lisp中也提供了类似于Map和Reduce的操作 如: (map ’vector #+#(1 2 3 4 5) #(10 11 12 13 14)) 通过定义加法map运算将2个向量相加产生结果#(11 13 15 17 19) (reduce #’+#(11 13 15 17 19)) 通过加法归并产生累加结果75 Map: 对一组数据元素进行某种重复式的处理 Reduce: 对Map的中间结果进行某种进一步的结果整理 示例： Map和Reduce操作的抽象描述 基于Map和Reduce的并行计算模型 各个map函数对所划分的数据并行处理，从不同的输入数据产生不同的中间结果输出。 各个reduce也各自并行计算，各自负责处理不同的中间结果数据集合。 进行reduce处理之前，必须等到所有的map函数做完，因此，在进入reduce前需要有一个同步障(barrier)；这个阶段也负责对map的中间结果数据进行收集整理(aggregation &amp; shuffle)处理，以便reduce更有效地计算最终结果。 最终汇总所有reduce的输出结果即可获得最终结果。 如何提供统一的计算框架 MapReduce提供一个统一的计算框架，可完成： 计算任务的划分和调度 数据的分布存储和划分 处理数据与计算任务的同步 结果数据的收集整理(sorting, combining, partitioning…) 系统通信、负载平衡、计算性能优化处理 处理系统节点出错检测和失效恢复 MapReduce最大的亮点 通过抽象模型和计算框架把需要做什么(what need to do)与具体怎么做(how to do)分开了，为程序员提供一个抽象和高层的编程接口和框架。 程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。 如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来，交给计算框架去处理：从分布代码的执行，到大到数千小到单个节点集群的自动调度使用。 *MapReduce提供的主要功能 MapReduce有四大主要功能： 数据划分和计算任务调度 提交的一个计算作业（Job)将被划分为很多个计算任务（Tasks)。 任务调度功能主要负责为这些划分后的计算任务分配和调度计算结点（Map 结点或 Reduce 结点），同时负责监控这些结点的执行状态，以及 Map 结点执行的同步控制，也负责进行一些计算性能优化处理。例如，对最慢的计算任务采用多备份执行，选最快完成者作为结果。 数据/程序互定位 为了减少数据通信量，一个基本原则是本地化数据处理，即一个计算结点尽可能处理其本地磁盘上分布存储的数据，这实现了代码向数据的迁移。 当无法进行这种本地化数据处理时，再寻找其他可用结点并将数据从网络上传送给该结点（数据向代码迁移)，但将尽可能从数据所在的本地机架上寻找可用结点以减少通信延迟。 出错处理 在以低端商用服务器构成的大规模 MapReduce 计算集群中，结点硬件（主机、兹盘、内存等）出错和软件有缺陷是常态。因此，MapReduce 架构需要能检测并隔离出错结点，并调度分配新的结点接管出错结点的计算任务。 分布式数据存储与文件管理 海量数据处理需要一个良好的分布数据存储和文件管理系统作为支撑，该系统能够把海量数据分布存储在各个结点的本地磁盘上，但保持整个数据在逻辑上成为一个完整的数据文件。 为了提供数据存储容错机制，该系统还要提供数据块的多备份存储管理能力。 Combiner 和 Partitioner 为了减少数据通信开销，中间结果数据进入 Reduce 结点前需要进行合并（Combine）处理，即把具有同样主键的数据合并到一起避免重复传送。 一个 Reduce 结点所处理的数据可能会来自多个 Map 结点，因此，Map 结点输出的中间结果需使用一定的策略进行适当的划分（Partition）处理，保证相关数据发送到同一个Reduce结点上。 自动并行化并隐藏系统层细节 MapReduce的主要思想和特征 向“外”横向扩展，而非向“上”纵向扩展 失效被认为是常态 把处理向数据迁移 顺序处理数据、避免随机访问数据 为应用开发者隐藏系统层细节 平滑无缝的可扩展性 CH4 Google MapReduce基本架构 回顾一下Google的三驾马车：GFS、MapReduce、Bigtable Google MapReduce的基本工作原理 Google MapReduce并行处理的基本过程 失效处理 主节点失效 主节点中会周期性地设置检查点(checkpoint)，检查整个计算作业的执行情况，一旦某个任务失效，可以从最近有效的检查点开始重新执行，避免从头开始计算的时间浪费。 如果只有一个Master，它不太可能失败；因此，如果Master失败，将中止MapReduce计算。 工作节点失效 工作节点失效是很普遍发生的，主节点会周期性地给工作节点发送检测命令，如果工作节点没有回应，这认为该工作节点失效，主节点将终止该工作节点的任务并把失效的任务重新调度到其它工作节点上重新执行。 带宽优化 问题 大量的键值对数据在传送给Reduce节点时会引起较大的通信带宽开销。 解决方案 每个Map节点处理完成的中间键值对将由combiner做一个合并压缩，即把那些键名相同的键值对归并为一个键名下的一组数值。 计算优化 问题 Reduce节点必须要等到所有Map节点计算结束才能开始执行，因此，如果有一个计算量大、或者由于某个问题导致很慢结束的Map节点，则会成为严重的“拖后腿者”。 解决方案 把一个Map计算任务让多个Map节点同时做，取最快完成者的计算结果。 用数据分区解决数据相关性问题 问题 一个Reduce节点上的计算数据可能会来自多个Map节点，因此，为了在进入Reduce节点计算之前，需要把属于一个Reduce节点的数据归并到一起。 解决方案 在Map阶段进行了Combining以后，可以根据一定的策略对Map输出的中间结果进行分区(partitioning)，这样即可解决以上数据相关性问题避免Reduce计算过程中的数据通信。 例如：有一个巨大的数组，其最终结果需要排序，每个Map节点数据处理好后，为了避免在每个Reduce节点本地排序完成后还需要进行全局排序，我们可以使用一个分区策略如:(d%R)，d为数据大小，R为Reduce节点的个数，则可根据数据的大小将其划分到指定数据范围的Reduce节点上，每个Reduce将本地数据排好序后即为最终结果。 分布式文件系统GFS的工作原理 GPS是什么？ Google GFS是一个基于分布式集群的大型分布式文件系统，为MapReduce计算框架提供数据存储和数据可靠性支撑； GFS是一个构建在分布节点本地文件系统之上的一个逻辑上文件系统，它将数据存储在物理上分布的每个节点上，但通过GFS将整个数据形成一个逻辑上整体的文件。 Google GFS的基本设计原则 廉价本地磁盘分布存储 各节点本地分布式存储数据，优点是不需要采用价格较贵的集中式磁盘阵列，容量可随节点数增加自动增加 多数据自动备份解决可靠性 采用廉价的普通磁盘，把磁盘数据出错视为常态，用自动多数据备份存储解决数据存储可靠性问题 为上层的MapReduce计算框架提供支撑 GFS作为向上层MapReduce执行框架的底层数据存储支撑，负责处理所有的数据自动存储和容错处理，因而上层框架不需要考虑底层的数据存储和数据容错问题 Google GFS的基本架构和工作原理 基本架构 GFS Master GFS ChunkServer 工作原理：数据访问工作过程 在程序运行前，数据已经存储在GFS文件系统中；程序运行时应用程序会告诉GFS Server所要访问的文件名或者数据块索引是什么。 GFS Server根据文件名和数据块索引在其文件目录空间中查找和定位该文件或数据块，找出数据块具体在哪些ChunkServer上；将这些位置信息回送给应用程序。 应用程序根据GFS Server返回的具体Chunk数据块位置信息，直接访问相应的ChunkServer。 应用程序根据GFS Server返回的具体Chunk数据块位置信息直接读取指定位置的数据进行计算处理。 以上过程的特点是：应用程序访问具体数据的时候不需要经过GFS Master，避免了Master成为访问性能瓶颈；另一方面，由于大量数据会存储在不同的ChunkServer中，应用可实现并发访问。 GFS的系统管理技术 大规模集群安装技术：如何在一个成千上万个节点的集群上迅速部署GFS，升级管理和维护等。 故障检测技术：GFS是构建在不可靠的廉价计算机之上的文件系统，节点数多，故障频繁，如何快速检测、定位、恢复或隔离故障节点。 节点动态加入技术：当新的节点加入时，需要能自动安装和部署GFS。 节能技术：服务器的耗电成本大于购买成本，Google为每个节点服务器配置了蓄电池替代UPS，大大节省了能耗。 分布式结构化数据表BigTable的基本工作原理 BigTable的基本作用和设计思想 GPS是一个分布式文件管理系统，不适合用来存储和管理结构化数据。因此在GFS之上又设计了一个结构化数据存储和访问管理系统—BigTable，为应用程序提供比单纯的文件系统更方便、更高层的数据操作能力，同时提供了一定粒度的结构化数据操作能力。 但是它结构化粒度低，没有事务处理能力，因此不是真正意义上的数据库。 BigTable的设计动机和目标 广泛的适用性：为一系列服务和应用而设计的数据存储系统，可满足对不同类型数据的存储和操作需求 很强的可扩展性：根据需要可随时自动加入或撤销服务器节点 高吞吐量数据访问：提供P级数据存储能力，每秒数百万次的访问请求 高可用性和容错性：保证系统在各种情况下都能正常运转，服务不中断 自动管理能力：自动加入和撤销服务器，自动负载平衡 简单性：系统设计尽量简单以减少复杂性和出错率 BigTable数据模型 BigTable主要是一个分布式多维表，表中的数据通过： 一个行关键字（row key） 一个列关键字（column key） 一个时间戳（timestamp） 进行索引和查询定位的。 BigTable对存储在表中的数据不做任何解释，一律视为字节串，具体数据结构的实现由用户自行定义。 BigTable查询模型 (row:string, column:string,time:int64)-&gt;结果数据字节串 支持查询、插入和删除操作 BigTable数据存储格式： 行(Row):大小不超过64KB的任意字符串。表中的数据都是根据行关键字进行排序的。 com.cnn.www就是一个行关键字，指明一行存储数据。URL地址倒排好处是：1)同一地址的网页将被存储在表中连续的位置，便于查找；2)倒排便于数据压缩，可大幅提高数据压缩率。 子表(Tablet)：一个大表可能太大，不利于存储管理，将在水平方向上被分为多个子表。 列(Column): BigTable将列关键字组织成为“列族”(column family)，每个族中的数据属于同一类别，如anchor是一个列族，其下可有不同的表示一个个超链的列关键字。一个列族下的数据会被压缩在一起存放（按列存放）。因此，一个列关键字可表示为： 族名：列名(family:qualifier) content、anchor都是族名；而cnnsi.com和my.look.ca则是anchor族中的列名。 时间戳(time stamp):很多时候同一个URL的网页会不断更新，而Google需要保存不同时间的网页数据，因此需要使用时间戳来加以区分。 为了简化不同版本的数据管理，BigTable提供给了两种设置： 保留最近的n个版本数据 保留限定时间内的所有不同版本数据 BigTable基本架构 CH5 Hadoop基本架构 Hadoop平台的基本组成与生态系统 Hadoop是一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。 Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。 Hadoop的核心是分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce。 Hadoop特性 可靠、高效、可伸缩 高可靠性 高效性 高可扩展性 高容错性 成本低 运行在Linux平台上 支持多种编程语言 基本组成与生态系统 分布式文件系统HDFS HDFS模仿Google GFS设计实现。 HDFS基本特征 存储极大数目的信息/极大的单个文件 提供数据的高可靠性和容错能力 提供对数据的快速访问 …… HDFS基本构架 HDFS的主要组件有NameNode，DataNode。 用一个表来直观展示它们的功能： NameNode DataNode 存储元数据 存储文件内容 元数据保存在内存中 文件内容保存在磁盘 保存文件，block，datanode之间的映射关系 维护了block id到datanode本地文件的映射关系 NameNode充当了HDFS的主节点，负责元数据管理，DataNode充当了多个从节点，负责数据的存储和处理，而SecondaryNameNode是辅助节点，用于辅助主要的NameNode在元数据管理方面。这种架构模式有助于实现HDFS的可伸缩性、容错性和负载均衡。 NameNode 这是NameNode的目录结构： 在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），记录了每个文件中各个块所在的数据节点的位置信息，保存了两个核心的数据结构，即FsImage和EditLog。其中： FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据。 FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一个文件或目录的元数据的内部表示。 操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作 启动过程 在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行EditLog文件中的各项操作，使得内存中的元数据和实际的同步，存在内存中的元数据支持客户端的读操作。 一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件。 名称节点起来之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前，edits文件都需要同步更新。 名称节点运行期间EditLog不断变大的问题 在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文件将会变得很大。 虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用。 SecondaryNameNode SecondaryNameNode本质上是NameNode的备份，NameNode也可以看作是FirstNameNode。 SecondaryNameNode的目录结构： SecondaryNameNode是HDFS架构中的一个组成部分，它是用来保存名称节点（NameNode）中对HDFS元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上。 工作流程： SecondaryNameNode会定期和NameNode通信 从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下 执行EditLog和FsImage文件合并 将新的FsImage文件发送到NameNode节点上 NameNode使用新的FsImage和EditLog（缩小了） 第二名称节点用途： 不是热备份 主要是防止日志文件EditLog过大，导致名称节点失败恢复时消耗过多时间（主要） 附带起到冷备份功能 HDFS命名空间管理 HDFS的命名空间包含目录、文件和块。 在HDFS1.0体系结构中，在整个HDFS集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。 HDFS使用的是传统的分级文件体系，因此，用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件，重命名文件等。 HDFS通信协议 所有的HDFS通信协议都是构建在TCP/IP协议基础之上的。 客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互。 名称节点和数据节点之间则使用数据节点协议进行交互。 客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求。 HDFS数据存取 数据存放 第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点 第二个副本：放置在与第一个副本不同的机架的节点上 第三个副本：与第一个副本相同机架的其他节点上 更多副本：随机节点 数据读取 HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID（Rack Awareness）。 当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。 HDFS可靠性与出错恢复 NameNode出错 备份（SecondaryNameNode） 对于NameNode，HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。 高可用性（HA） HDFS HA（High Availability）是为了解决单点故障问题。 在Hadoop 2.x以后的版本中，HA集群设置两个名称节点，活跃（Active）和待命（Standby）。两种名称节点的状态同步，可以借助于一个共享存储系统来实现。一旦活跃名称节点出现故障，就可以立即切换到待命名称节点。 DataNode出错 数据复制 HDFS会将每个文件的数据块在多个DataNode上进行复制存储，默认情况下，每个数据块会有三个副本。这样，即使某个DataNode发生故障，文件的数据仍然可以从其他DataNode上的副本中访问到。 心跳检测 NameNode会定期向所有DataNode发送心跳信号，如果一段时间内没有收到某个DataNode的心跳信号，NameNode就会认为这个DataNode发生了故障，然后会将这个DataNode上的数据块的副本重新分配到其他DataNode上，以保证数据的可用性和可靠性。 数据一致性和校验和（Checksum） HDFS通过使用校验和来保证数据的一致性。 当数据写入HDFS时，会在客户端计算每个数据块的校验和，并将校验和和数据块一起存储在DataNode上。 当数据从HDFS读取时，会在客户端重新计算数据块的校验和，并与存储在DataNode上的校验和进行比较，如果两者不一致，说明数据在传输过程中可能发生了错误，客户端可以请求从其他DataNode上读取数据块的其他副本。 通过这种方式，HDFS可以在一定程度上保证数据的一致性和可靠性。 HDFS纠删码（EC） EC，是一种编码容错技术。最早用于通信行业，数据传输中的数据恢复。它通过对数据进行分块，然后计算出校验数据，使得各个部分的数据产生关联性。当一部分数据块丢失时，可以通过剩余的数据块和校验块计算出丢失的数据块。 优势：节约存储空间 劣势： 网络带宽的消耗，因为数据恢复需要去读其他的数据块和校验块 进行编码，解码计算需要消耗CPU资源 最好的选择是用于冷数据集群 冷数据集群往往有大量的长期没有被访问的数据，体量确实很大，采用EC技术，可以大大减少副本数 冷数据集群基本稳定，耗资源量少，所以一旦进行数据恢复，将不会对集群造成大的影响 YARN：新一代Hadoop架构 第二代Hadoop引入了YARN作为资源管理工具。 理念 YARN的目标就是实现“一个集群多个框架” ，即在一个集群上部署一个统一的资源调度管理框架YARN，在YARN之上可以部署其他各种计算框架。 YARN的优势在于： 由YARN为这些计算框架提供统一的资源调度管理服务。 且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。 可以实现一个集群上的不同应用负载混搭，有效提高了集群的利用率。 不同计算框架可以共享底层存储，避免了数据集跨集群移动。 YARN实现了： 更高的集群利用率，一个框架未使用的资源可由另一个框架进行使用，充分的避免资源浪费。 在新的Yarn中，通过加入ApplicationMaster是一个可变更的部分，用户可以针对不同的编程模型编写自己的ApplicationMaster，让更多的编程模型运行在Hadoop集群中。 在上一版框架中，JobTracker一个很大的负担就是监控Job的tasks运行情况，现在，这个部分下放到了ApplicationMaster中它的思路主要是：将原来的JobTracker三大功能拆分。 实现方式 Yet Another Resource Negotiator：另一种资源协调者。它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。 ResourceManager (RM）全局管理所有应用程序计算资源的分配，每个应用的ApplicationMaster (AM)负责相应的调度和协调。 一个应用程序无非是一个单独的传统的 MapReduce 任务或者是一个 DAG（有向无环图）任务。ResourceManager和每一台机器的节点管理服务器能够管理用户在那台机器上的进程并能对计算进行组织。 Hadoop MapReduce基本工作过程" />
<meta property="og:description" content="CH1 大数据 三次信息化浪潮 四种研究范式 大数据 定义 大数据意指一个超大的、难以用现有常规的数据库管理技术和工具 处理的数据集。 5V特征 Volume（大体量）：即可从数百TB到数十数百PB，甚至EB的规模 Variety（多样性）：即大数据包括各种格式和形态的数据 Velocity（时效性）：即很多大数据需要在一定的时间限度下得到及时处理 Veracity（准确性）：即处理的结果要保证一定的准确性 Value（大价值）：即大数据包含很多深度的价值，大数据分析挖掘和利用将带来巨大的商业价值 结构化/半结构化/非结构化 结构化数据：结构化数据是指在预定义的数据模型中组织的数据，通常存储在关系数据库中。它们有严格的格式和规则，例如行和列的表格。 半结构化数据：半结构化数据介于结构化数据和非结构化数据之间。它们没有严格的数据模型，但有某种形式的结构。例如JSON就是一个常见的数据格式，它有一些形式的规范（例如分隔），但可以存储数值，字符串等多种类型的元素。 非结构化数据：非结构化数据是没有特定结构的数据。这种数据类型包括文本、视频、音频、社交媒体发布等。 不同类型 大数据问题的特点和研究原则 基本特点 大数据来自应用行业，具有极强的行业应用需求特性 数据规模极大，达到PB甚至EB量级，超过任何传统数据库系统的处理能力 大数据处理给传统计算技术带来极大挑战，大多数传统算法在面向大数据处理时都面临问题，需要重写 基本原则 应用需求为导向：以行业应用问题和需求为出发点 领域交叉为桥梁：行业、IT产业、学术界协同 计算技术为支撑：研究解决涉及的计算技术问题 大数据的引擎 是软件，软件改变世界！ 大数据研究基本目标 以有效的信息技术手段和计算方法，获取、处理和分析各类应用行 业的大数据，发现和提取数据的内在价值，为行业提供高附加值的 应用和服务。 技术手段：信息技术和计算方法 核心目标：价值发现 效益目标：形成高附加值行业应用 大数据研究的挑战和基本途径 挑战 数据规模导致难以应付的存储量 数据规模导致传统算法失效 大数据复杂的数据关联性导致高复杂度的计算 基本途径 寻找新算法降低计算复杂度 降低大数据尺度，寻找数据尺度无关算法 大数据并行化处理 大数据典型和热点技术问题 大数据涉及的关键技术 金融大数据 金融数据：一般具有“流数据”特征，需要在短时间内快速处理。 具有逻辑关系紧密，处理实时性要求高，可展示性需求强等特征。 数据分析技术：数据挖掘，机器学习等AI技术 数据管理技术：关系型和非关系型数据管理、数据融合和集成技术、ETL等技术 数据处理技术：分布式计算，内存计算，流处理技术等 数据展示技术：可视化技术、历史流展示技术、空间信息流展示技术等。 CH2 并行计算技术 如何提高计算机性能？ 为什么要并行计算技术？为了提高计算机性能！ 提高处理器字长 提高集成度（限制：摩尔定律） 流水线等微体系结构技术 提高处理器频率 但是存在以下问题，导致单核处理器性能提升接近极限： VLSI集成度不可能无限制提高 处理器的指令级并行度提升接近极限（ILP墙） 处理器速度和存储器速度差异越来越大（CPU约为1ns，而主存约为100ns） 功耗和散热大幅增加超过芯片承受能力 并行计算技术的发展趋势和影响 越来越多的研究和应用领域需要使用并行计算技术 并行计算技术将渗透到每个计算应用领域，尤其是涉及到大规模数据和复杂计算的应用领域 并行计算技术将对传统计算技术产生革命性的影响 并行计算技术将影响传统计算技术的各个层面，与传统计算技术相互结合产生很多新的研究热点和课题 很多传统的串行算法和计算方法都将需要重新研究和设计其并行化算法和计算方法 并行计算技术的分类 弗林分类 并行类型分类 存储访问结构分类 系统类型分类 计算特征分类 并行程序设计模型/方法分类 发展趋势 并行计算主要技术问题 多核/多处理器网络互联结构技术 存储访问体系结构 分布式数据与文件管理 并行计算任务的分解与算法设计 并行程序设计模型和方法 数据同步访问和通信控制 可靠性设计与容错技术 并行计算软件框架平台 系统性能评估和程序并行度评估 MPI并行程序设计 MPI是什么？ MPI (Message Passing Interface)，基于消息传递的高性能并行计算编程接口。MPI在处理器间以消息传递方式进行数据通信和同步，以库函数形式为程序员提供了一组易于使用的编程接口。 特点：提供可靠的、面向消息的通信；在高性能科学计算领域广泛使用，适合于处理计算密集型的科学计算；独立于语言的编程规范，可移植性好。 MPI并行程序设计的时候需要注意什么？ 消息传递并行程序设计 用户必须通过显式地发送和接收消息来实现处理机间的数据交换。 每个并行进程均有自己独立的地址空间，相互之间访问不能直接进行，必须通过显式的消息传递来实现。 并行计算粒度大，特别适合于大规模可扩展并行算法 要求用户很好地分解问题，组织不同进程间的数据交换，并行计算粒度大。 MPI主要功能（通信方式） 用常规语言编程方式，所有节点运行同一个程序，但处理不同的数据 提供点对点通信(Point-point communication) 提供同步通信功能（阻塞通信） 提供异步通信功能（非阻塞通信） 提供节点集合通信(Collective communication) 提供一对多的广播通信 提供多节点计算同步控制 提供对结果的规约(Reduce)计算功能 提供用户自定义的复合数据类型传输 方式及相关接口整理如下： MPI提供三大类通信方式： 点对点通信 同步通信：阻塞式通信，等待通信操作完成后才返回。 MPI_Send (buf, count, datatype, dest, tag, comm) : 发送一个消息 MPI_Recv (buf, count, datatype, source, tag, comm, status) : 接受消息 异步通信：非阻塞式通信，不等待通信操作完成即返回。 MPI_ISend (buf, count, datatype, dest, tag, comm, request) : 异步发送 MPI_IRecv (buf, count, datatype, source, tag, comm, status, request) 异步接受消息 MPI_Wait (request, status) : 等待非阻塞数据传输完成 MPI_Test (request, flag, status) : 检查是否异步数据传输确实完成 节点集合通信 一对多的广播通信。主要有以下接口： MPI_BCAST: 一对多的广播式发送 多节点计算同步控制。主要有以下接口： MPI_GATHER：多个进程的消息以某种次序收集到一个进程 MPI_SCATTER：将一个信息划分为等长的段依次发送给其它进程 对结果的规约（Reduce）计算功能 MPI_Reduce：将一组进程的数据按照指定的操作方式规约到一起并传送给一个进程 用户自定义的复合数据类型传输 MPI程序 MPI基本程序结构 MPI并行程序设计接口 MPI编程示例 节点集合通信接口 提供一个进程与多个进程间同时通信的功能。 集合通信功能 数据规约操作 MPI特点和不足 MPI的特点 灵活性好，适合于各种计算密集型的并行计算任务 独立于语言的编程规范，可移植性好 有很多开放机构或厂商实现并支持 MPI的不足 无良好的数据和任务划分支持 缺少分布文件系统支持分布数据存储管理 通信开销大，当计算问题复杂、节点数量很大时，难以处理，性能大幅下降 无节点失效恢复机制，一旦有节点失效，可能导致计算过程无效 缺少良好的构架支撑，程序员需要考虑以上所有细节问题，程序设计较为复杂 CH3 MapReduce简介 MapReduce的基本模型和处理思想 三大设计思想 分而治之：处理大数据 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。 并行抽象模型：Mapper与Reducer MPI等并行计算方法缺少高层并行编程模型，为了克服这一缺陷，MapReduce借鉴了Lisp函数式语言中的思想，用Map和Reduce两个函数提供了高层的并行编程抽象模型。 统一构架，隐藏系统层细节 MPI等并行计算方法缺少统一的计算框架支持，程序员需要考虑数据存储、划分、分发、结果收集、错误恢复等诸多细节；为此，MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。 分而治之：处理大数据 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。 不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算！ 并行化计算示例： 概念： Master：负责划分和分配任务 Worker：负责数据块计算 构建抽象模型：Mapper与Reducer Map和Reduce的工作方式 MapReduce借鉴了函数式设计语言Lisp的设计思想。 Lisp定义了可对列表元素进行整体处理的各种操作，如： (add #(1 2 3 4) #(4 3 2 1)) 将产生结果： #(5 5 5 5) Lisp中也提供了类似于Map和Reduce的操作 如: (map ’vector #+#(1 2 3 4 5) #(10 11 12 13 14)) 通过定义加法map运算将2个向量相加产生结果#(11 13 15 17 19) (reduce #’+#(11 13 15 17 19)) 通过加法归并产生累加结果75 Map: 对一组数据元素进行某种重复式的处理 Reduce: 对Map的中间结果进行某种进一步的结果整理 示例： Map和Reduce操作的抽象描述 基于Map和Reduce的并行计算模型 各个map函数对所划分的数据并行处理，从不同的输入数据产生不同的中间结果输出。 各个reduce也各自并行计算，各自负责处理不同的中间结果数据集合。 进行reduce处理之前，必须等到所有的map函数做完，因此，在进入reduce前需要有一个同步障(barrier)；这个阶段也负责对map的中间结果数据进行收集整理(aggregation &amp; shuffle)处理，以便reduce更有效地计算最终结果。 最终汇总所有reduce的输出结果即可获得最终结果。 如何提供统一的计算框架 MapReduce提供一个统一的计算框架，可完成： 计算任务的划分和调度 数据的分布存储和划分 处理数据与计算任务的同步 结果数据的收集整理(sorting, combining, partitioning…) 系统通信、负载平衡、计算性能优化处理 处理系统节点出错检测和失效恢复 MapReduce最大的亮点 通过抽象模型和计算框架把需要做什么(what need to do)与具体怎么做(how to do)分开了，为程序员提供一个抽象和高层的编程接口和框架。 程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。 如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来，交给计算框架去处理：从分布代码的执行，到大到数千小到单个节点集群的自动调度使用。 *MapReduce提供的主要功能 MapReduce有四大主要功能： 数据划分和计算任务调度 提交的一个计算作业（Job)将被划分为很多个计算任务（Tasks)。 任务调度功能主要负责为这些划分后的计算任务分配和调度计算结点（Map 结点或 Reduce 结点），同时负责监控这些结点的执行状态，以及 Map 结点执行的同步控制，也负责进行一些计算性能优化处理。例如，对最慢的计算任务采用多备份执行，选最快完成者作为结果。 数据/程序互定位 为了减少数据通信量，一个基本原则是本地化数据处理，即一个计算结点尽可能处理其本地磁盘上分布存储的数据，这实现了代码向数据的迁移。 当无法进行这种本地化数据处理时，再寻找其他可用结点并将数据从网络上传送给该结点（数据向代码迁移)，但将尽可能从数据所在的本地机架上寻找可用结点以减少通信延迟。 出错处理 在以低端商用服务器构成的大规模 MapReduce 计算集群中，结点硬件（主机、兹盘、内存等）出错和软件有缺陷是常态。因此，MapReduce 架构需要能检测并隔离出错结点，并调度分配新的结点接管出错结点的计算任务。 分布式数据存储与文件管理 海量数据处理需要一个良好的分布数据存储和文件管理系统作为支撑，该系统能够把海量数据分布存储在各个结点的本地磁盘上，但保持整个数据在逻辑上成为一个完整的数据文件。 为了提供数据存储容错机制，该系统还要提供数据块的多备份存储管理能力。 Combiner 和 Partitioner 为了减少数据通信开销，中间结果数据进入 Reduce 结点前需要进行合并（Combine）处理，即把具有同样主键的数据合并到一起避免重复传送。 一个 Reduce 结点所处理的数据可能会来自多个 Map 结点，因此，Map 结点输出的中间结果需使用一定的策略进行适当的划分（Partition）处理，保证相关数据发送到同一个Reduce结点上。 自动并行化并隐藏系统层细节 MapReduce的主要思想和特征 向“外”横向扩展，而非向“上”纵向扩展 失效被认为是常态 把处理向数据迁移 顺序处理数据、避免随机访问数据 为应用开发者隐藏系统层细节 平滑无缝的可扩展性 CH4 Google MapReduce基本架构 回顾一下Google的三驾马车：GFS、MapReduce、Bigtable Google MapReduce的基本工作原理 Google MapReduce并行处理的基本过程 失效处理 主节点失效 主节点中会周期性地设置检查点(checkpoint)，检查整个计算作业的执行情况，一旦某个任务失效，可以从最近有效的检查点开始重新执行，避免从头开始计算的时间浪费。 如果只有一个Master，它不太可能失败；因此，如果Master失败，将中止MapReduce计算。 工作节点失效 工作节点失效是很普遍发生的，主节点会周期性地给工作节点发送检测命令，如果工作节点没有回应，这认为该工作节点失效，主节点将终止该工作节点的任务并把失效的任务重新调度到其它工作节点上重新执行。 带宽优化 问题 大量的键值对数据在传送给Reduce节点时会引起较大的通信带宽开销。 解决方案 每个Map节点处理完成的中间键值对将由combiner做一个合并压缩，即把那些键名相同的键值对归并为一个键名下的一组数值。 计算优化 问题 Reduce节点必须要等到所有Map节点计算结束才能开始执行，因此，如果有一个计算量大、或者由于某个问题导致很慢结束的Map节点，则会成为严重的“拖后腿者”。 解决方案 把一个Map计算任务让多个Map节点同时做，取最快完成者的计算结果。 用数据分区解决数据相关性问题 问题 一个Reduce节点上的计算数据可能会来自多个Map节点，因此，为了在进入Reduce节点计算之前，需要把属于一个Reduce节点的数据归并到一起。 解决方案 在Map阶段进行了Combining以后，可以根据一定的策略对Map输出的中间结果进行分区(partitioning)，这样即可解决以上数据相关性问题避免Reduce计算过程中的数据通信。 例如：有一个巨大的数组，其最终结果需要排序，每个Map节点数据处理好后，为了避免在每个Reduce节点本地排序完成后还需要进行全局排序，我们可以使用一个分区策略如:(d%R)，d为数据大小，R为Reduce节点的个数，则可根据数据的大小将其划分到指定数据范围的Reduce节点上，每个Reduce将本地数据排好序后即为最终结果。 分布式文件系统GFS的工作原理 GPS是什么？ Google GFS是一个基于分布式集群的大型分布式文件系统，为MapReduce计算框架提供数据存储和数据可靠性支撑； GFS是一个构建在分布节点本地文件系统之上的一个逻辑上文件系统，它将数据存储在物理上分布的每个节点上，但通过GFS将整个数据形成一个逻辑上整体的文件。 Google GFS的基本设计原则 廉价本地磁盘分布存储 各节点本地分布式存储数据，优点是不需要采用价格较贵的集中式磁盘阵列，容量可随节点数增加自动增加 多数据自动备份解决可靠性 采用廉价的普通磁盘，把磁盘数据出错视为常态，用自动多数据备份存储解决数据存储可靠性问题 为上层的MapReduce计算框架提供支撑 GFS作为向上层MapReduce执行框架的底层数据存储支撑，负责处理所有的数据自动存储和容错处理，因而上层框架不需要考虑底层的数据存储和数据容错问题 Google GFS的基本架构和工作原理 基本架构 GFS Master GFS ChunkServer 工作原理：数据访问工作过程 在程序运行前，数据已经存储在GFS文件系统中；程序运行时应用程序会告诉GFS Server所要访问的文件名或者数据块索引是什么。 GFS Server根据文件名和数据块索引在其文件目录空间中查找和定位该文件或数据块，找出数据块具体在哪些ChunkServer上；将这些位置信息回送给应用程序。 应用程序根据GFS Server返回的具体Chunk数据块位置信息，直接访问相应的ChunkServer。 应用程序根据GFS Server返回的具体Chunk数据块位置信息直接读取指定位置的数据进行计算处理。 以上过程的特点是：应用程序访问具体数据的时候不需要经过GFS Master，避免了Master成为访问性能瓶颈；另一方面，由于大量数据会存储在不同的ChunkServer中，应用可实现并发访问。 GFS的系统管理技术 大规模集群安装技术：如何在一个成千上万个节点的集群上迅速部署GFS，升级管理和维护等。 故障检测技术：GFS是构建在不可靠的廉价计算机之上的文件系统，节点数多，故障频繁，如何快速检测、定位、恢复或隔离故障节点。 节点动态加入技术：当新的节点加入时，需要能自动安装和部署GFS。 节能技术：服务器的耗电成本大于购买成本，Google为每个节点服务器配置了蓄电池替代UPS，大大节省了能耗。 分布式结构化数据表BigTable的基本工作原理 BigTable的基本作用和设计思想 GPS是一个分布式文件管理系统，不适合用来存储和管理结构化数据。因此在GFS之上又设计了一个结构化数据存储和访问管理系统—BigTable，为应用程序提供比单纯的文件系统更方便、更高层的数据操作能力，同时提供了一定粒度的结构化数据操作能力。 但是它结构化粒度低，没有事务处理能力，因此不是真正意义上的数据库。 BigTable的设计动机和目标 广泛的适用性：为一系列服务和应用而设计的数据存储系统，可满足对不同类型数据的存储和操作需求 很强的可扩展性：根据需要可随时自动加入或撤销服务器节点 高吞吐量数据访问：提供P级数据存储能力，每秒数百万次的访问请求 高可用性和容错性：保证系统在各种情况下都能正常运转，服务不中断 自动管理能力：自动加入和撤销服务器，自动负载平衡 简单性：系统设计尽量简单以减少复杂性和出错率 BigTable数据模型 BigTable主要是一个分布式多维表，表中的数据通过： 一个行关键字（row key） 一个列关键字（column key） 一个时间戳（timestamp） 进行索引和查询定位的。 BigTable对存储在表中的数据不做任何解释，一律视为字节串，具体数据结构的实现由用户自行定义。 BigTable查询模型 (row:string, column:string,time:int64)-&gt;结果数据字节串 支持查询、插入和删除操作 BigTable数据存储格式： 行(Row):大小不超过64KB的任意字符串。表中的数据都是根据行关键字进行排序的。 com.cnn.www就是一个行关键字，指明一行存储数据。URL地址倒排好处是：1)同一地址的网页将被存储在表中连续的位置，便于查找；2)倒排便于数据压缩，可大幅提高数据压缩率。 子表(Tablet)：一个大表可能太大，不利于存储管理，将在水平方向上被分为多个子表。 列(Column): BigTable将列关键字组织成为“列族”(column family)，每个族中的数据属于同一类别，如anchor是一个列族，其下可有不同的表示一个个超链的列关键字。一个列族下的数据会被压缩在一起存放（按列存放）。因此，一个列关键字可表示为： 族名：列名(family:qualifier) content、anchor都是族名；而cnnsi.com和my.look.ca则是anchor族中的列名。 时间戳(time stamp):很多时候同一个URL的网页会不断更新，而Google需要保存不同时间的网页数据，因此需要使用时间戳来加以区分。 为了简化不同版本的数据管理，BigTable提供给了两种设置： 保留最近的n个版本数据 保留限定时间内的所有不同版本数据 BigTable基本架构 CH5 Hadoop基本架构 Hadoop平台的基本组成与生态系统 Hadoop是一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。 Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。 Hadoop的核心是分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce。 Hadoop特性 可靠、高效、可伸缩 高可靠性 高效性 高可扩展性 高容错性 成本低 运行在Linux平台上 支持多种编程语言 基本组成与生态系统 分布式文件系统HDFS HDFS模仿Google GFS设计实现。 HDFS基本特征 存储极大数目的信息/极大的单个文件 提供数据的高可靠性和容错能力 提供对数据的快速访问 …… HDFS基本构架 HDFS的主要组件有NameNode，DataNode。 用一个表来直观展示它们的功能： NameNode DataNode 存储元数据 存储文件内容 元数据保存在内存中 文件内容保存在磁盘 保存文件，block，datanode之间的映射关系 维护了block id到datanode本地文件的映射关系 NameNode充当了HDFS的主节点，负责元数据管理，DataNode充当了多个从节点，负责数据的存储和处理，而SecondaryNameNode是辅助节点，用于辅助主要的NameNode在元数据管理方面。这种架构模式有助于实现HDFS的可伸缩性、容错性和负载均衡。 NameNode 这是NameNode的目录结构： 在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），记录了每个文件中各个块所在的数据节点的位置信息，保存了两个核心的数据结构，即FsImage和EditLog。其中： FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据。 FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一个文件或目录的元数据的内部表示。 操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作 启动过程 在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行EditLog文件中的各项操作，使得内存中的元数据和实际的同步，存在内存中的元数据支持客户端的读操作。 一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件。 名称节点起来之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前，edits文件都需要同步更新。 名称节点运行期间EditLog不断变大的问题 在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文件将会变得很大。 虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用。 SecondaryNameNode SecondaryNameNode本质上是NameNode的备份，NameNode也可以看作是FirstNameNode。 SecondaryNameNode的目录结构： SecondaryNameNode是HDFS架构中的一个组成部分，它是用来保存名称节点（NameNode）中对HDFS元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上。 工作流程： SecondaryNameNode会定期和NameNode通信 从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下 执行EditLog和FsImage文件合并 将新的FsImage文件发送到NameNode节点上 NameNode使用新的FsImage和EditLog（缩小了） 第二名称节点用途： 不是热备份 主要是防止日志文件EditLog过大，导致名称节点失败恢复时消耗过多时间（主要） 附带起到冷备份功能 HDFS命名空间管理 HDFS的命名空间包含目录、文件和块。 在HDFS1.0体系结构中，在整个HDFS集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。 HDFS使用的是传统的分级文件体系，因此，用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件，重命名文件等。 HDFS通信协议 所有的HDFS通信协议都是构建在TCP/IP协议基础之上的。 客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互。 名称节点和数据节点之间则使用数据节点协议进行交互。 客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求。 HDFS数据存取 数据存放 第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点 第二个副本：放置在与第一个副本不同的机架的节点上 第三个副本：与第一个副本相同机架的其他节点上 更多副本：随机节点 数据读取 HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID（Rack Awareness）。 当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。 HDFS可靠性与出错恢复 NameNode出错 备份（SecondaryNameNode） 对于NameNode，HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。 高可用性（HA） HDFS HA（High Availability）是为了解决单点故障问题。 在Hadoop 2.x以后的版本中，HA集群设置两个名称节点，活跃（Active）和待命（Standby）。两种名称节点的状态同步，可以借助于一个共享存储系统来实现。一旦活跃名称节点出现故障，就可以立即切换到待命名称节点。 DataNode出错 数据复制 HDFS会将每个文件的数据块在多个DataNode上进行复制存储，默认情况下，每个数据块会有三个副本。这样，即使某个DataNode发生故障，文件的数据仍然可以从其他DataNode上的副本中访问到。 心跳检测 NameNode会定期向所有DataNode发送心跳信号，如果一段时间内没有收到某个DataNode的心跳信号，NameNode就会认为这个DataNode发生了故障，然后会将这个DataNode上的数据块的副本重新分配到其他DataNode上，以保证数据的可用性和可靠性。 数据一致性和校验和（Checksum） HDFS通过使用校验和来保证数据的一致性。 当数据写入HDFS时，会在客户端计算每个数据块的校验和，并将校验和和数据块一起存储在DataNode上。 当数据从HDFS读取时，会在客户端重新计算数据块的校验和，并与存储在DataNode上的校验和进行比较，如果两者不一致，说明数据在传输过程中可能发生了错误，客户端可以请求从其他DataNode上读取数据块的其他副本。 通过这种方式，HDFS可以在一定程度上保证数据的一致性和可靠性。 HDFS纠删码（EC） EC，是一种编码容错技术。最早用于通信行业，数据传输中的数据恢复。它通过对数据进行分块，然后计算出校验数据，使得各个部分的数据产生关联性。当一部分数据块丢失时，可以通过剩余的数据块和校验块计算出丢失的数据块。 优势：节约存储空间 劣势： 网络带宽的消耗，因为数据恢复需要去读其他的数据块和校验块 进行编码，解码计算需要消耗CPU资源 最好的选择是用于冷数据集群 冷数据集群往往有大量的长期没有被访问的数据，体量确实很大，采用EC技术，可以大大减少副本数 冷数据集群基本稳定，耗资源量少，所以一旦进行数据恢复，将不会对集群造成大的影响 YARN：新一代Hadoop架构 第二代Hadoop引入了YARN作为资源管理工具。 理念 YARN的目标就是实现“一个集群多个框架” ，即在一个集群上部署一个统一的资源调度管理框架YARN，在YARN之上可以部署其他各种计算框架。 YARN的优势在于： 由YARN为这些计算框架提供统一的资源调度管理服务。 且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。 可以实现一个集群上的不同应用负载混搭，有效提高了集群的利用率。 不同计算框架可以共享底层存储，避免了数据集跨集群移动。 YARN实现了： 更高的集群利用率，一个框架未使用的资源可由另一个框架进行使用，充分的避免资源浪费。 在新的Yarn中，通过加入ApplicationMaster是一个可变更的部分，用户可以针对不同的编程模型编写自己的ApplicationMaster，让更多的编程模型运行在Hadoop集群中。 在上一版框架中，JobTracker一个很大的负担就是监控Job的tasks运行情况，现在，这个部分下放到了ApplicationMaster中它的思路主要是：将原来的JobTracker三大功能拆分。 实现方式 Yet Another Resource Negotiator：另一种资源协调者。它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。 ResourceManager (RM）全局管理所有应用程序计算资源的分配，每个应用的ApplicationMaster (AM)负责相应的调度和协调。 一个应用程序无非是一个单独的传统的 MapReduce 任务或者是一个 DAG（有向无环图）任务。ResourceManager和每一台机器的节点管理服务器能够管理用户在那台机器上的进程并能对计算进行组织。 Hadoop MapReduce基本工作过程" />
<link rel="canonical" href="/lecturenotes/2023/09/01/%E9%87%91%E8%9E%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.html" />
<meta property="og:url" content="/lecturenotes/2023/09/01/%E9%87%91%E8%9E%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.html" />
<meta property="og:site_name" content="Step far." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-09-01T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="金融大数据处理技术笔记" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"DragonK"},"dateModified":"2023-09-01T00:00:00+00:00","datePublished":"2023-09-01T00:00:00+00:00","description":"CH1 大数据 三次信息化浪潮 四种研究范式 大数据 定义 大数据意指一个超大的、难以用现有常规的数据库管理技术和工具 处理的数据集。 5V特征 Volume（大体量）：即可从数百TB到数十数百PB，甚至EB的规模 Variety（多样性）：即大数据包括各种格式和形态的数据 Velocity（时效性）：即很多大数据需要在一定的时间限度下得到及时处理 Veracity（准确性）：即处理的结果要保证一定的准确性 Value（大价值）：即大数据包含很多深度的价值，大数据分析挖掘和利用将带来巨大的商业价值 结构化/半结构化/非结构化 结构化数据：结构化数据是指在预定义的数据模型中组织的数据，通常存储在关系数据库中。它们有严格的格式和规则，例如行和列的表格。 半结构化数据：半结构化数据介于结构化数据和非结构化数据之间。它们没有严格的数据模型，但有某种形式的结构。例如JSON就是一个常见的数据格式，它有一些形式的规范（例如分隔），但可以存储数值，字符串等多种类型的元素。 非结构化数据：非结构化数据是没有特定结构的数据。这种数据类型包括文本、视频、音频、社交媒体发布等。 不同类型 大数据问题的特点和研究原则 基本特点 大数据来自应用行业，具有极强的行业应用需求特性 数据规模极大，达到PB甚至EB量级，超过任何传统数据库系统的处理能力 大数据处理给传统计算技术带来极大挑战，大多数传统算法在面向大数据处理时都面临问题，需要重写 基本原则 应用需求为导向：以行业应用问题和需求为出发点 领域交叉为桥梁：行业、IT产业、学术界协同 计算技术为支撑：研究解决涉及的计算技术问题 大数据的引擎 是软件，软件改变世界！ 大数据研究基本目标 以有效的信息技术手段和计算方法，获取、处理和分析各类应用行 业的大数据，发现和提取数据的内在价值，为行业提供高附加值的 应用和服务。 技术手段：信息技术和计算方法 核心目标：价值发现 效益目标：形成高附加值行业应用 大数据研究的挑战和基本途径 挑战 数据规模导致难以应付的存储量 数据规模导致传统算法失效 大数据复杂的数据关联性导致高复杂度的计算 基本途径 寻找新算法降低计算复杂度 降低大数据尺度，寻找数据尺度无关算法 大数据并行化处理 大数据典型和热点技术问题 大数据涉及的关键技术 金融大数据 金融数据：一般具有“流数据”特征，需要在短时间内快速处理。 具有逻辑关系紧密，处理实时性要求高，可展示性需求强等特征。 数据分析技术：数据挖掘，机器学习等AI技术 数据管理技术：关系型和非关系型数据管理、数据融合和集成技术、ETL等技术 数据处理技术：分布式计算，内存计算，流处理技术等 数据展示技术：可视化技术、历史流展示技术、空间信息流展示技术等。 CH2 并行计算技术 如何提高计算机性能？ 为什么要并行计算技术？为了提高计算机性能！ 提高处理器字长 提高集成度（限制：摩尔定律） 流水线等微体系结构技术 提高处理器频率 但是存在以下问题，导致单核处理器性能提升接近极限： VLSI集成度不可能无限制提高 处理器的指令级并行度提升接近极限（ILP墙） 处理器速度和存储器速度差异越来越大（CPU约为1ns，而主存约为100ns） 功耗和散热大幅增加超过芯片承受能力 并行计算技术的发展趋势和影响 越来越多的研究和应用领域需要使用并行计算技术 并行计算技术将渗透到每个计算应用领域，尤其是涉及到大规模数据和复杂计算的应用领域 并行计算技术将对传统计算技术产生革命性的影响 并行计算技术将影响传统计算技术的各个层面，与传统计算技术相互结合产生很多新的研究热点和课题 很多传统的串行算法和计算方法都将需要重新研究和设计其并行化算法和计算方法 并行计算技术的分类 弗林分类 并行类型分类 存储访问结构分类 系统类型分类 计算特征分类 并行程序设计模型/方法分类 发展趋势 并行计算主要技术问题 多核/多处理器网络互联结构技术 存储访问体系结构 分布式数据与文件管理 并行计算任务的分解与算法设计 并行程序设计模型和方法 数据同步访问和通信控制 可靠性设计与容错技术 并行计算软件框架平台 系统性能评估和程序并行度评估 MPI并行程序设计 MPI是什么？ MPI (Message Passing Interface)，基于消息传递的高性能并行计算编程接口。MPI在处理器间以消息传递方式进行数据通信和同步，以库函数形式为程序员提供了一组易于使用的编程接口。 特点：提供可靠的、面向消息的通信；在高性能科学计算领域广泛使用，适合于处理计算密集型的科学计算；独立于语言的编程规范，可移植性好。 MPI并行程序设计的时候需要注意什么？ 消息传递并行程序设计 用户必须通过显式地发送和接收消息来实现处理机间的数据交换。 每个并行进程均有自己独立的地址空间，相互之间访问不能直接进行，必须通过显式的消息传递来实现。 并行计算粒度大，特别适合于大规模可扩展并行算法 要求用户很好地分解问题，组织不同进程间的数据交换，并行计算粒度大。 MPI主要功能（通信方式） 用常规语言编程方式，所有节点运行同一个程序，但处理不同的数据 提供点对点通信(Point-point communication) 提供同步通信功能（阻塞通信） 提供异步通信功能（非阻塞通信） 提供节点集合通信(Collective communication) 提供一对多的广播通信 提供多节点计算同步控制 提供对结果的规约(Reduce)计算功能 提供用户自定义的复合数据类型传输 方式及相关接口整理如下： MPI提供三大类通信方式： 点对点通信 同步通信：阻塞式通信，等待通信操作完成后才返回。 MPI_Send (buf, count, datatype, dest, tag, comm) : 发送一个消息 MPI_Recv (buf, count, datatype, source, tag, comm, status) : 接受消息 异步通信：非阻塞式通信，不等待通信操作完成即返回。 MPI_ISend (buf, count, datatype, dest, tag, comm, request) : 异步发送 MPI_IRecv (buf, count, datatype, source, tag, comm, status, request) 异步接受消息 MPI_Wait (request, status) : 等待非阻塞数据传输完成 MPI_Test (request, flag, status) : 检查是否异步数据传输确实完成 节点集合通信 一对多的广播通信。主要有以下接口： MPI_BCAST: 一对多的广播式发送 多节点计算同步控制。主要有以下接口： MPI_GATHER：多个进程的消息以某种次序收集到一个进程 MPI_SCATTER：将一个信息划分为等长的段依次发送给其它进程 对结果的规约（Reduce）计算功能 MPI_Reduce：将一组进程的数据按照指定的操作方式规约到一起并传送给一个进程 用户自定义的复合数据类型传输 MPI程序 MPI基本程序结构 MPI并行程序设计接口 MPI编程示例 节点集合通信接口 提供一个进程与多个进程间同时通信的功能。 集合通信功能 数据规约操作 MPI特点和不足 MPI的特点 灵活性好，适合于各种计算密集型的并行计算任务 独立于语言的编程规范，可移植性好 有很多开放机构或厂商实现并支持 MPI的不足 无良好的数据和任务划分支持 缺少分布文件系统支持分布数据存储管理 通信开销大，当计算问题复杂、节点数量很大时，难以处理，性能大幅下降 无节点失效恢复机制，一旦有节点失效，可能导致计算过程无效 缺少良好的构架支撑，程序员需要考虑以上所有细节问题，程序设计较为复杂 CH3 MapReduce简介 MapReduce的基本模型和处理思想 三大设计思想 分而治之：处理大数据 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。 并行抽象模型：Mapper与Reducer MPI等并行计算方法缺少高层并行编程模型，为了克服这一缺陷，MapReduce借鉴了Lisp函数式语言中的思想，用Map和Reduce两个函数提供了高层的并行编程抽象模型。 统一构架，隐藏系统层细节 MPI等并行计算方法缺少统一的计算框架支持，程序员需要考虑数据存储、划分、分发、结果收集、错误恢复等诸多细节；为此，MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。 分而治之：处理大数据 对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取分而治之的策略。 不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算！ 并行化计算示例： 概念： Master：负责划分和分配任务 Worker：负责数据块计算 构建抽象模型：Mapper与Reducer Map和Reduce的工作方式 MapReduce借鉴了函数式设计语言Lisp的设计思想。 Lisp定义了可对列表元素进行整体处理的各种操作，如： (add #(1 2 3 4) #(4 3 2 1)) 将产生结果： #(5 5 5 5) Lisp中也提供了类似于Map和Reduce的操作 如: (map ’vector #+#(1 2 3 4 5) #(10 11 12 13 14)) 通过定义加法map运算将2个向量相加产生结果#(11 13 15 17 19) (reduce #’+#(11 13 15 17 19)) 通过加法归并产生累加结果75 Map: 对一组数据元素进行某种重复式的处理 Reduce: 对Map的中间结果进行某种进一步的结果整理 示例： Map和Reduce操作的抽象描述 基于Map和Reduce的并行计算模型 各个map函数对所划分的数据并行处理，从不同的输入数据产生不同的中间结果输出。 各个reduce也各自并行计算，各自负责处理不同的中间结果数据集合。 进行reduce处理之前，必须等到所有的map函数做完，因此，在进入reduce前需要有一个同步障(barrier)；这个阶段也负责对map的中间结果数据进行收集整理(aggregation &amp; shuffle)处理，以便reduce更有效地计算最终结果。 最终汇总所有reduce的输出结果即可获得最终结果。 如何提供统一的计算框架 MapReduce提供一个统一的计算框架，可完成： 计算任务的划分和调度 数据的分布存储和划分 处理数据与计算任务的同步 结果数据的收集整理(sorting, combining, partitioning…) 系统通信、负载平衡、计算性能优化处理 处理系统节点出错检测和失效恢复 MapReduce最大的亮点 通过抽象模型和计算框架把需要做什么(what need to do)与具体怎么做(how to do)分开了，为程序员提供一个抽象和高层的编程接口和框架。 程序员仅需要关心其应用层的具体计算问题，仅需编写少量的处理应用本身计算问题的程序代码。 如何具体完成这个并行计算任务所相关的诸多系统层细节被隐藏起来，交给计算框架去处理：从分布代码的执行，到大到数千小到单个节点集群的自动调度使用。 *MapReduce提供的主要功能 MapReduce有四大主要功能： 数据划分和计算任务调度 提交的一个计算作业（Job)将被划分为很多个计算任务（Tasks)。 任务调度功能主要负责为这些划分后的计算任务分配和调度计算结点（Map 结点或 Reduce 结点），同时负责监控这些结点的执行状态，以及 Map 结点执行的同步控制，也负责进行一些计算性能优化处理。例如，对最慢的计算任务采用多备份执行，选最快完成者作为结果。 数据/程序互定位 为了减少数据通信量，一个基本原则是本地化数据处理，即一个计算结点尽可能处理其本地磁盘上分布存储的数据，这实现了代码向数据的迁移。 当无法进行这种本地化数据处理时，再寻找其他可用结点并将数据从网络上传送给该结点（数据向代码迁移)，但将尽可能从数据所在的本地机架上寻找可用结点以减少通信延迟。 出错处理 在以低端商用服务器构成的大规模 MapReduce 计算集群中，结点硬件（主机、兹盘、内存等）出错和软件有缺陷是常态。因此，MapReduce 架构需要能检测并隔离出错结点，并调度分配新的结点接管出错结点的计算任务。 分布式数据存储与文件管理 海量数据处理需要一个良好的分布数据存储和文件管理系统作为支撑，该系统能够把海量数据分布存储在各个结点的本地磁盘上，但保持整个数据在逻辑上成为一个完整的数据文件。 为了提供数据存储容错机制，该系统还要提供数据块的多备份存储管理能力。 Combiner 和 Partitioner 为了减少数据通信开销，中间结果数据进入 Reduce 结点前需要进行合并（Combine）处理，即把具有同样主键的数据合并到一起避免重复传送。 一个 Reduce 结点所处理的数据可能会来自多个 Map 结点，因此，Map 结点输出的中间结果需使用一定的策略进行适当的划分（Partition）处理，保证相关数据发送到同一个Reduce结点上。 自动并行化并隐藏系统层细节 MapReduce的主要思想和特征 向“外”横向扩展，而非向“上”纵向扩展 失效被认为是常态 把处理向数据迁移 顺序处理数据、避免随机访问数据 为应用开发者隐藏系统层细节 平滑无缝的可扩展性 CH4 Google MapReduce基本架构 回顾一下Google的三驾马车：GFS、MapReduce、Bigtable Google MapReduce的基本工作原理 Google MapReduce并行处理的基本过程 失效处理 主节点失效 主节点中会周期性地设置检查点(checkpoint)，检查整个计算作业的执行情况，一旦某个任务失效，可以从最近有效的检查点开始重新执行，避免从头开始计算的时间浪费。 如果只有一个Master，它不太可能失败；因此，如果Master失败，将中止MapReduce计算。 工作节点失效 工作节点失效是很普遍发生的，主节点会周期性地给工作节点发送检测命令，如果工作节点没有回应，这认为该工作节点失效，主节点将终止该工作节点的任务并把失效的任务重新调度到其它工作节点上重新执行。 带宽优化 问题 大量的键值对数据在传送给Reduce节点时会引起较大的通信带宽开销。 解决方案 每个Map节点处理完成的中间键值对将由combiner做一个合并压缩，即把那些键名相同的键值对归并为一个键名下的一组数值。 计算优化 问题 Reduce节点必须要等到所有Map节点计算结束才能开始执行，因此，如果有一个计算量大、或者由于某个问题导致很慢结束的Map节点，则会成为严重的“拖后腿者”。 解决方案 把一个Map计算任务让多个Map节点同时做，取最快完成者的计算结果。 用数据分区解决数据相关性问题 问题 一个Reduce节点上的计算数据可能会来自多个Map节点，因此，为了在进入Reduce节点计算之前，需要把属于一个Reduce节点的数据归并到一起。 解决方案 在Map阶段进行了Combining以后，可以根据一定的策略对Map输出的中间结果进行分区(partitioning)，这样即可解决以上数据相关性问题避免Reduce计算过程中的数据通信。 例如：有一个巨大的数组，其最终结果需要排序，每个Map节点数据处理好后，为了避免在每个Reduce节点本地排序完成后还需要进行全局排序，我们可以使用一个分区策略如:(d%R)，d为数据大小，R为Reduce节点的个数，则可根据数据的大小将其划分到指定数据范围的Reduce节点上，每个Reduce将本地数据排好序后即为最终结果。 分布式文件系统GFS的工作原理 GPS是什么？ Google GFS是一个基于分布式集群的大型分布式文件系统，为MapReduce计算框架提供数据存储和数据可靠性支撑； GFS是一个构建在分布节点本地文件系统之上的一个逻辑上文件系统，它将数据存储在物理上分布的每个节点上，但通过GFS将整个数据形成一个逻辑上整体的文件。 Google GFS的基本设计原则 廉价本地磁盘分布存储 各节点本地分布式存储数据，优点是不需要采用价格较贵的集中式磁盘阵列，容量可随节点数增加自动增加 多数据自动备份解决可靠性 采用廉价的普通磁盘，把磁盘数据出错视为常态，用自动多数据备份存储解决数据存储可靠性问题 为上层的MapReduce计算框架提供支撑 GFS作为向上层MapReduce执行框架的底层数据存储支撑，负责处理所有的数据自动存储和容错处理，因而上层框架不需要考虑底层的数据存储和数据容错问题 Google GFS的基本架构和工作原理 基本架构 GFS Master GFS ChunkServer 工作原理：数据访问工作过程 在程序运行前，数据已经存储在GFS文件系统中；程序运行时应用程序会告诉GFS Server所要访问的文件名或者数据块索引是什么。 GFS Server根据文件名和数据块索引在其文件目录空间中查找和定位该文件或数据块，找出数据块具体在哪些ChunkServer上；将这些位置信息回送给应用程序。 应用程序根据GFS Server返回的具体Chunk数据块位置信息，直接访问相应的ChunkServer。 应用程序根据GFS Server返回的具体Chunk数据块位置信息直接读取指定位置的数据进行计算处理。 以上过程的特点是：应用程序访问具体数据的时候不需要经过GFS Master，避免了Master成为访问性能瓶颈；另一方面，由于大量数据会存储在不同的ChunkServer中，应用可实现并发访问。 GFS的系统管理技术 大规模集群安装技术：如何在一个成千上万个节点的集群上迅速部署GFS，升级管理和维护等。 故障检测技术：GFS是构建在不可靠的廉价计算机之上的文件系统，节点数多，故障频繁，如何快速检测、定位、恢复或隔离故障节点。 节点动态加入技术：当新的节点加入时，需要能自动安装和部署GFS。 节能技术：服务器的耗电成本大于购买成本，Google为每个节点服务器配置了蓄电池替代UPS，大大节省了能耗。 分布式结构化数据表BigTable的基本工作原理 BigTable的基本作用和设计思想 GPS是一个分布式文件管理系统，不适合用来存储和管理结构化数据。因此在GFS之上又设计了一个结构化数据存储和访问管理系统—BigTable，为应用程序提供比单纯的文件系统更方便、更高层的数据操作能力，同时提供了一定粒度的结构化数据操作能力。 但是它结构化粒度低，没有事务处理能力，因此不是真正意义上的数据库。 BigTable的设计动机和目标 广泛的适用性：为一系列服务和应用而设计的数据存储系统，可满足对不同类型数据的存储和操作需求 很强的可扩展性：根据需要可随时自动加入或撤销服务器节点 高吞吐量数据访问：提供P级数据存储能力，每秒数百万次的访问请求 高可用性和容错性：保证系统在各种情况下都能正常运转，服务不中断 自动管理能力：自动加入和撤销服务器，自动负载平衡 简单性：系统设计尽量简单以减少复杂性和出错率 BigTable数据模型 BigTable主要是一个分布式多维表，表中的数据通过： 一个行关键字（row key） 一个列关键字（column key） 一个时间戳（timestamp） 进行索引和查询定位的。 BigTable对存储在表中的数据不做任何解释，一律视为字节串，具体数据结构的实现由用户自行定义。 BigTable查询模型 (row:string, column:string,time:int64)-&gt;结果数据字节串 支持查询、插入和删除操作 BigTable数据存储格式： 行(Row):大小不超过64KB的任意字符串。表中的数据都是根据行关键字进行排序的。 com.cnn.www就是一个行关键字，指明一行存储数据。URL地址倒排好处是：1)同一地址的网页将被存储在表中连续的位置，便于查找；2)倒排便于数据压缩，可大幅提高数据压缩率。 子表(Tablet)：一个大表可能太大，不利于存储管理，将在水平方向上被分为多个子表。 列(Column): BigTable将列关键字组织成为“列族”(column family)，每个族中的数据属于同一类别，如anchor是一个列族，其下可有不同的表示一个个超链的列关键字。一个列族下的数据会被压缩在一起存放（按列存放）。因此，一个列关键字可表示为： 族名：列名(family:qualifier) content、anchor都是族名；而cnnsi.com和my.look.ca则是anchor族中的列名。 时间戳(time stamp):很多时候同一个URL的网页会不断更新，而Google需要保存不同时间的网页数据，因此需要使用时间戳来加以区分。 为了简化不同版本的数据管理，BigTable提供给了两种设置： 保留最近的n个版本数据 保留限定时间内的所有不同版本数据 BigTable基本架构 CH5 Hadoop基本架构 Hadoop平台的基本组成与生态系统 Hadoop是一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。 Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。 Hadoop的核心是分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce。 Hadoop特性 可靠、高效、可伸缩 高可靠性 高效性 高可扩展性 高容错性 成本低 运行在Linux平台上 支持多种编程语言 基本组成与生态系统 分布式文件系统HDFS HDFS模仿Google GFS设计实现。 HDFS基本特征 存储极大数目的信息/极大的单个文件 提供数据的高可靠性和容错能力 提供对数据的快速访问 …… HDFS基本构架 HDFS的主要组件有NameNode，DataNode。 用一个表来直观展示它们的功能： NameNode DataNode 存储元数据 存储文件内容 元数据保存在内存中 文件内容保存在磁盘 保存文件，block，datanode之间的映射关系 维护了block id到datanode本地文件的映射关系 NameNode充当了HDFS的主节点，负责元数据管理，DataNode充当了多个从节点，负责数据的存储和处理，而SecondaryNameNode是辅助节点，用于辅助主要的NameNode在元数据管理方面。这种架构模式有助于实现HDFS的可伸缩性、容错性和负载均衡。 NameNode 这是NameNode的目录结构： 在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），记录了每个文件中各个块所在的数据节点的位置信息，保存了两个核心的数据结构，即FsImage和EditLog。其中： FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据。 FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一个文件或目录的元数据的内部表示。 操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作 启动过程 在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行EditLog文件中的各项操作，使得内存中的元数据和实际的同步，存在内存中的元数据支持客户端的读操作。 一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件。 名称节点起来之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前，edits文件都需要同步更新。 名称节点运行期间EditLog不断变大的问题 在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文件将会变得很大。 虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用。 SecondaryNameNode SecondaryNameNode本质上是NameNode的备份，NameNode也可以看作是FirstNameNode。 SecondaryNameNode的目录结构： SecondaryNameNode是HDFS架构中的一个组成部分，它是用来保存名称节点（NameNode）中对HDFS元数据信息的备份，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上。 工作流程： SecondaryNameNode会定期和NameNode通信 从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下 执行EditLog和FsImage文件合并 将新的FsImage文件发送到NameNode节点上 NameNode使用新的FsImage和EditLog（缩小了） 第二名称节点用途： 不是热备份 主要是防止日志文件EditLog过大，导致名称节点失败恢复时消耗过多时间（主要） 附带起到冷备份功能 HDFS命名空间管理 HDFS的命名空间包含目录、文件和块。 在HDFS1.0体系结构中，在整个HDFS集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。 HDFS使用的是传统的分级文件体系，因此，用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件，重命名文件等。 HDFS通信协议 所有的HDFS通信协议都是构建在TCP/IP协议基础之上的。 客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互。 名称节点和数据节点之间则使用数据节点协议进行交互。 客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求。 HDFS数据存取 数据存放 第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点 第二个副本：放置在与第一个副本不同的机架的节点上 第三个副本：与第一个副本相同机架的其他节点上 更多副本：随机节点 数据读取 HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID（Rack Awareness）。 当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据，如果没有发现，就随机选择一个副本读取数据。 HDFS可靠性与出错恢复 NameNode出错 备份（SecondaryNameNode） 对于NameNode，HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。 高可用性（HA） HDFS HA（High Availability）是为了解决单点故障问题。 在Hadoop 2.x以后的版本中，HA集群设置两个名称节点，活跃（Active）和待命（Standby）。两种名称节点的状态同步，可以借助于一个共享存储系统来实现。一旦活跃名称节点出现故障，就可以立即切换到待命名称节点。 DataNode出错 数据复制 HDFS会将每个文件的数据块在多个DataNode上进行复制存储，默认情况下，每个数据块会有三个副本。这样，即使某个DataNode发生故障，文件的数据仍然可以从其他DataNode上的副本中访问到。 心跳检测 NameNode会定期向所有DataNode发送心跳信号，如果一段时间内没有收到某个DataNode的心跳信号，NameNode就会认为这个DataNode发生了故障，然后会将这个DataNode上的数据块的副本重新分配到其他DataNode上，以保证数据的可用性和可靠性。 数据一致性和校验和（Checksum） HDFS通过使用校验和来保证数据的一致性。 当数据写入HDFS时，会在客户端计算每个数据块的校验和，并将校验和和数据块一起存储在DataNode上。 当数据从HDFS读取时，会在客户端重新计算数据块的校验和，并与存储在DataNode上的校验和进行比较，如果两者不一致，说明数据在传输过程中可能发生了错误，客户端可以请求从其他DataNode上读取数据块的其他副本。 通过这种方式，HDFS可以在一定程度上保证数据的一致性和可靠性。 HDFS纠删码（EC） EC，是一种编码容错技术。最早用于通信行业，数据传输中的数据恢复。它通过对数据进行分块，然后计算出校验数据，使得各个部分的数据产生关联性。当一部分数据块丢失时，可以通过剩余的数据块和校验块计算出丢失的数据块。 优势：节约存储空间 劣势： 网络带宽的消耗，因为数据恢复需要去读其他的数据块和校验块 进行编码，解码计算需要消耗CPU资源 最好的选择是用于冷数据集群 冷数据集群往往有大量的长期没有被访问的数据，体量确实很大，采用EC技术，可以大大减少副本数 冷数据集群基本稳定，耗资源量少，所以一旦进行数据恢复，将不会对集群造成大的影响 YARN：新一代Hadoop架构 第二代Hadoop引入了YARN作为资源管理工具。 理念 YARN的目标就是实现“一个集群多个框架” ，即在一个集群上部署一个统一的资源调度管理框架YARN，在YARN之上可以部署其他各种计算框架。 YARN的优势在于： 由YARN为这些计算框架提供统一的资源调度管理服务。 且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。 可以实现一个集群上的不同应用负载混搭，有效提高了集群的利用率。 不同计算框架可以共享底层存储，避免了数据集跨集群移动。 YARN实现了： 更高的集群利用率，一个框架未使用的资源可由另一个框架进行使用，充分的避免资源浪费。 在新的Yarn中，通过加入ApplicationMaster是一个可变更的部分，用户可以针对不同的编程模型编写自己的ApplicationMaster，让更多的编程模型运行在Hadoop集群中。 在上一版框架中，JobTracker一个很大的负担就是监控Job的tasks运行情况，现在，这个部分下放到了ApplicationMaster中它的思路主要是：将原来的JobTracker三大功能拆分。 实现方式 Yet Another Resource Negotiator：另一种资源协调者。它是一个通用资源管理系统，可为上层应用提供统一的资源管理和调度，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。 ResourceManager (RM）全局管理所有应用程序计算资源的分配，每个应用的ApplicationMaster (AM)负责相应的调度和协调。 一个应用程序无非是一个单独的传统的 MapReduce 任务或者是一个 DAG（有向无环图）任务。ResourceManager和每一台机器的节点管理服务器能够管理用户在那台机器上的进程并能对计算进行组织。 Hadoop MapReduce基本工作过程","headline":"金融大数据处理技术笔记","mainEntityOfPage":{"@type":"WebPage","@id":"/lecturenotes/2023/09/01/%E9%87%91%E8%9E%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.html"},"url":"/lecturenotes/2023/09/01/%E9%87%91%E8%9E%8D%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Step far." /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8"
        src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"
        async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script
  src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script
  src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link
  href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css"
  rel="stylesheet"
/>
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = ``.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
</head>
<body>



























































































































<header class="site-header site-header-transparent" role="banner">

  <div class="wrapper">
    <div class="site-header-inner"><span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Step far." src="" onerror="this.style.display='none'">
  Step far.
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>

          <div class="trigger"><a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</span></div>
        </nav></div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;documentElement.setAttribute("data-header-transparent", "");var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<section class="page-banner">
    <div class="page-banner-img"><div style="background-image: url(/assets/images/banners/toho.jpeg)"></div>
        <img class="img-placeholder" src="/assets/images/banners/toho.jpeg"></div>
    <div class="wrapper">
      <div class="page-banner-inner"><header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">金融大数据处理技术笔记</h1>
  <h2 class="post-subtitle">FBDP</h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2023-09-01T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Sep 01, 2023
    </time>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 9 mins</span>
  </div><div class="post-tags"><a class="post-tag" href="/tags.html#FBDP">#FBDP</a></div></header>
</div>
    </div>
  </section><script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="ch1-大数据">CH1 大数据</h2>

<h3 id="三次信息化浪潮">三次信息化浪潮</h3>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918202007883.png" alt="image-20230918202007883" /></p>

<h3 id="四种研究范式">四种研究范式</h3>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918202055346.png" alt="image-20230918202055346" /></p>

<h3 id="大数据">大数据</h3>

<h4 id="定义">定义</h4>

<p>大数据意指一个超大的、难以用现有常规的数据库管理技术和工具</p>

<p>处理的数据集。</p>

<h4 id="5v特征">5V特征</h4>

<ul>
  <li>
    <p>Volume（大体量）：即可从数百TB到数十数百PB，甚至EB的规模</p>
  </li>
  <li>Variety（多样性）：即大数据包括各种格式和形态的数据</li>
  <li>Velocity（时效性）：即很多大数据需要在一定的时间限度下得到及时处理</li>
  <li>Veracity（准确性）：即处理的结果要保证一定的准确性</li>
  <li>Value（大价值）：即大数据包含很多深度的价值，大数据分析挖掘和利用将带来巨大的商业价值</li>
</ul>

<h4 id="结构化半结构化非结构化">结构化/半结构化/非结构化</h4>

<ul>
  <li>结构化数据：结构化数据是指在预定义的数据模型中组织的数据，通常存储在关系数据库中。它们有严格的格式和规则，例如行和列的表格。</li>
  <li>半结构化数据：半结构化数据介于结构化数据和非结构化数据之间。它们没有严格的数据模型，但有某种形式的结构。例如JSON就是一个常见的数据格式，它有一些形式的规范（例如分隔），但可以存储数值，字符串等多种类型的元素。</li>
  <li>非结构化数据：非结构化数据是没有特定结构的数据。这种数据类型包括文本、视频、音频、社交媒体发布等。</li>
</ul>

<h4 id="不同类型">不同类型</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918202424665.png" alt="image-20230918202424665" /></p>

<h4 id="大数据问题的特点和研究原则">大数据问题的特点和研究原则</h4>

<h5 id="基本特点">基本特点</h5>

<ul>
  <li>大数据来自应用行业，<strong>具有极强的行业应用需求特性</strong></li>
  <li><strong>数据规模极大</strong>，达到PB甚至EB量级，超过任何传统数据库系统的处理能力</li>
  <li>大数据处理给传统计算技术带来极大挑战，大多数传统算法在面向大数据处理时都面临问题，需要重写</li>
</ul>

<h5 id="基本原则">基本原则</h5>

<ul>
  <li>应用需求为导向：以行业应用问题和需求为出发点</li>
  <li>领域交叉为桥梁：行业、IT产业、学术界协同</li>
  <li>计算技术为支撑：研究解决涉及的计算技术问题</li>
</ul>

<h4 id="大数据的引擎">大数据的引擎</h4>

<p>是软件，软件改变世界！</p>

<h4 id="大数据研究基本目标">大数据研究基本目标</h4>

<p>以有效的信息技术手段和计算方法，获取、处理和分析各类应用行</p>

<p>业的大数据，发现和提取数据的内在价值，为行业提供高附加值的</p>

<p>应用和服务。</p>

<ul>
  <li>
    <p>技术手段：信息技术和计算方法</p>
  </li>
  <li>核心目标：价值发现</li>
  <li>效益目标：形成高附加值行业应用</li>
</ul>

<h4 id="大数据研究的挑战和基本途径">大数据研究的挑战和基本途径</h4>

<h5 id="挑战">挑战</h5>

<ul>
  <li>数据规模导致难以应付的存储量</li>
  <li>数据规模导致传统算法失效</li>
  <li>大数据复杂的数据关联性导致高复杂度的计算</li>
</ul>

<h5 id="基本途径">基本途径</h5>

<ul>
  <li>寻找新算法降低计算复杂度</li>
  <li>降低大数据尺度，寻找数据尺度无关算法</li>
  <li>大数据并行化处理</li>
</ul>

<h4 id="大数据典型和热点技术问题">大数据典型和热点技术问题</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918203024459.png" alt="image-20230918203024459" /></p>

<h4 id="大数据涉及的关键技术">大数据涉及的关键技术</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918203040453.png" alt="image-20230918203040453" /></p>

<h3 id="金融大数据">金融大数据</h3>

<p>金融数据：一般具有“流数据”特征，需要在短时间内快速处理。</p>

<p>具有逻辑关系紧密，处理实时性要求高，可展示性需求强等特征。</p>

<ul>
  <li>数据分析技术：数据挖掘，机器学习等AI技术</li>
  <li>数据管理技术：关系型和非关系型数据管理、数据融合和集成技术、ETL等技术</li>
  <li>数据处理技术：分布式计算，内存计算，流处理技术等</li>
  <li>数据展示技术：可视化技术、历史流展示技术、空间信息流展示技术等。</li>
</ul>

<h2 id="ch2-并行计算技术">CH2 并行计算技术</h2>

<h3 id="如何提高计算机性能">如何提高计算机性能？</h3>

<p>为什么要并行计算技术？为了提高计算机性能！</p>

<ul>
  <li>提高处理器字长</li>
  <li>提高集成度（限制：摩尔定律）</li>
  <li>流水线等微体系结构技术</li>
  <li>提高处理器频率</li>
</ul>

<p>但是存在以下问题，导致单核处理器性能提升接近极限：</p>

<ul>
  <li>VLSI集成度不可能无限制提高</li>
  <li>处理器的指令级并行度提升接近极限（ILP墙）</li>
  <li>处理器速度和存储器速度差异越来越大（CPU约为1ns，而主存约为100ns）</li>
  <li>功耗和散热大幅增加超过芯片承受能力</li>
</ul>

<h3 id="并行计算技术的发展趋势和影响">并行计算技术的发展趋势和影响</h3>

<ul>
  <li>
    <p>越来越多的研究和应用领域需要使用并行计算技术</p>

    <ul>
      <li>并行计算技术将渗透到每个计算应用领域，尤其是涉及到大规模数据和复杂计算的应用领域</li>
    </ul>
  </li>
  <li>
    <p>并行计算技术将对传统计算技术产生革命性的影响</p>

    <ul>
      <li>并行计算技术将影响传统计算技术的各个层面，与传统计算技术相互结合产生很多新的研究热点和课题</li>
      <li>很多传统的串行算法和计算方法都将需要重新研究和设计其并行化算法和计算方法</li>
    </ul>
  </li>
</ul>

<h3 id="并行计算技术的分类">并行计算技术的分类</h3>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204013792.png" alt="image-20230918204013792" /></p>

<h4 id="弗林分类">弗林分类</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204102025.png" alt="image-20230918204102025" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204042637.png" alt="image-20230918204042637" /></p>

<h4 id="并行类型分类">并行类型分类</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204123431.png" alt="image-20230918204123431" /></p>

<h4 id="存储访问结构分类">存储访问结构分类</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204135426.png" alt="image-20230918204135426" /></p>

<h4 id="系统类型分类">系统类型分类</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204146473.png" alt="image-20230918204146473" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204245145.png" alt="image-20230918204245145" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204254576.png" alt="image-20230918204254576" /></p>

<h4 id="计算特征分类">计算特征分类</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204304001.png" alt="image-20230918204304001" /></p>

<h4 id="并行程序设计模型方法分类">并行程序设计模型/方法分类</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204320137.png" alt="image-20230918204320137" /></p>

<h4 id="发展趋势">发展趋势</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918204816521.png" alt="image-20230918204816521" /></p>

<h3 id="并行计算主要技术问题">并行计算主要技术问题</h3>

<h4 id="多核多处理器网络互联结构技术">多核/多处理器网络互联结构技术</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918210121018.png" alt="image-20230918210121018" /></p>

<h4 id="存储访问体系结构">存储访问体系结构</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213547843.png" alt="image-20230918213547843" /></p>

<h4 id="分布式数据与文件管理">分布式数据与文件管理</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213558993.png" alt="image-20230918213558993" /></p>

<h4 id="并行计算任务的分解与算法设计">并行计算任务的分解与算法设计</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213607258.png" alt="image-20230918213607258" /></p>

<h4 id="并行程序设计模型和方法">并行程序设计模型和方法</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213619916.png" alt="image-20230918213619916" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213624978.png" alt="image-20230918213624978" /></p>

<h4 id="数据同步访问和通信控制">数据同步访问和通信控制</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213634694.png" alt="image-20230918213634694" /></p>

<h4 id="可靠性设计与容错技术">可靠性设计与容错技术</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213641126.png" alt="image-20230918213641126" /></p>

<h4 id="并行计算软件框架平台">并行计算软件框架平台</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213653843.png" alt="image-20230918213653843" /></p>

<h4 id="系统性能评估和程序并行度评估">系统性能评估和程序并行度评估</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213702207.png" alt="image-20230918213702207" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918213711778.png" alt="image-20230918213711778" /></p>

<h3 id="mpi并行程序设计">MPI并行程序设计</h3>

<h4 id="mpi是什么">MPI是什么？</h4>

<p>MPI (Message Passing Interface)，基于消息传递的高性能并行计算编程接口。MPI在处理器间以消息传递方式进行数据通信和同步，以库函数形式为程序员提供了一组易于使用的编程接口。</p>

<p>特点：提供可靠的、面向消息的通信；在高性能科学计算领域广泛使用，适合于处理计算密集型的科学计算；独立于语言的编程规范，可移植性好。</p>

<h4 id="mpi并行程序设计的时候需要注意什么">MPI并行程序设计的时候需要注意什么？</h4>

<ul>
  <li>
    <p>消息传递并行程序设计</p>

    <ul>
      <li>
        <p>用户必须通过显式地发送和接收消息来实现处理机间的数据交换。</p>
      </li>
      <li>
        <p>每个并行进程均有自己独立的地址空间，相互之间访问不能直接进行，必须通过显式的消息传递来实现。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>并行计算粒度大，特别适合于大规模可扩展并行算法</p>

    <ul>
      <li>要求用户很好地分解问题，组织不同进程间的数据交换，并行计算粒度大。</li>
    </ul>
  </li>
</ul>

<h4 id="mpi主要功能通信方式">MPI主要功能（通信方式）</h4>

<ul>
  <li>
    <p>用常规语言编程方式，所有节点运行同一个程序，但处理不同的数据</p>

    <ul>
      <li>
        <p>提供点对点通信(Point-point communication)</p>
      </li>
      <li>
        <p>提供同步通信功能（阻塞通信）</p>
      </li>
      <li>
        <p>提供异步通信功能（非阻塞通信）</p>
      </li>
    </ul>
  </li>
  <li>
    <p>提供节点集合通信(Collective communication)</p>

    <ul>
      <li>
        <p>提供一对多的广播通信</p>
      </li>
      <li>
        <p>提供多节点计算同步控制</p>
      </li>
      <li>
        <p>提供对结果的规约(Reduce)计算功能</p>
      </li>
    </ul>
  </li>
  <li>
    <p>提供用户自定义的复合数据类型传输</p>
  </li>
</ul>

<p>方式及相关接口整理如下：</p>

<p>MPI提供三大类通信方式：</p>

<ul>
  <li>点对点通信
    <ul>
      <li>同步通信：阻塞式通信，等待通信操作完成后才返回。
        <ul>
          <li><em>MPI_Send (buf, count, datatype, dest, tag, comm)</em> : 发送一个消息</li>
          <li><em>MPI_Recv (buf, count, datatype, source, tag, comm, status)</em> : 接受消息</li>
        </ul>
      </li>
      <li>异步通信：非阻塞式通信，不等待通信操作完成即返回。
        <ul>
          <li><em>MPI_ISend (buf, count, datatype, dest, tag, comm, request)</em> : 异步发送</li>
          <li><em>MPI_IRecv (buf, count, datatype, source, tag, comm, status, request)</em> 异步接受消息</li>
          <li><em>MPI_Wait (request, status)</em> : 等待非阻塞数据传输完成</li>
          <li><em>MPI_Test (request, flag, status)</em> : 检查是否异步数据传输确实完成</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>节点集合通信
    <ul>
      <li>一对多的广播通信。主要有以下接口：
        <ul>
          <li><em>MPI_BCAST</em>: 一对多的广播式发送</li>
        </ul>
      </li>
      <li>多节点计算同步控制。主要有以下接口：
        <ul>
          <li><em>MPI_GATHER</em>：多个进程的消息以某种次序收集到一个进程</li>
          <li><em>MPI_SCATTER</em>：将一个信息划分为等长的段依次发送给其它进程</li>
        </ul>
      </li>
      <li>对结果的规约（Reduce）计算功能
        <ul>
          <li><em>MPI_Reduce</em>：将一组进程的数据按照指定的操作方式规约到一起并传送给一个进程</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>用户自定义的复合数据类型传输</li>
</ul>

<h4 id="mpi程序">MPI程序</h4>

<h5 id="mpi基本程序结构">MPI基本程序结构</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215212360.png" alt="image-20230918215212360" /></p>

<h5 id="mpi并行程序设计接口">MPI并行程序设计接口</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215255309.png" alt="image-20230918215255309" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215301625.png" alt="image-20230918215301625" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215443383.png" alt="image-20230918215443383" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215447655.png" alt="image-20230918215447655" /></p>

<h5 id="mpi编程示例">MPI编程示例</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215456069.png" alt="image-20230918215456069" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215508951.png" alt="image-20230918215508951" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215516128.png" alt="image-20230918215516128" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215520244.png" alt="image-20230918215520244" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215523816.png" alt="image-20230918215523816" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215527512.png" alt="image-20230918215527512" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215531278.png" alt="image-20230918215531278" /></p>

<h4 id="节点集合通信接口">节点集合通信接口</h4>

<p>提供一个进程与多个进程间同时通信的功能。</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215554628.png" alt="image-20230918215554628" /></p>

<h5 id="集合通信功能">集合通信功能</h5>

<ul>
  <li><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215838357.png" alt="image-20230918215838357" /></li>
</ul>

<h5 id="数据规约操作">数据规约操作</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918215831126.png" alt="image-20230918215831126" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918220017793.png" alt="image-20230918220017793" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918220021991.png" alt="image-20230918220021991" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230918220027955.png" alt="image-20230918220027955" /></p>

<h4 id="mpi特点和不足">MPI特点和不足</h4>

<ul>
  <li><strong>MPI的特点</strong>
    <ul>
      <li>灵活性好，适合于各种计算密集型的并行计算任务</li>
      <li>独立于语言的编程规范，可移植性好</li>
      <li>有很多开放机构或厂商实现并支持</li>
    </ul>
  </li>
  <li><strong>MPI的不足</strong>
    <ul>
      <li>无良好的数据和任务划分支持</li>
      <li>缺少分布文件系统支持分布数据存储管理</li>
      <li>通信开销大，当计算问题复杂、节点数量很大时，难以处理，性能大幅下降</li>
      <li>无节点失效恢复机制，一旦有节点失效，可能导致计算过程无效</li>
      <li>缺少良好的构架支撑，程序员需要考虑以上所有细节问题，程序设计较为复杂</li>
    </ul>
  </li>
</ul>

<h2 id="ch3-mapreduce简介">CH3 MapReduce简介</h2>

<h3 id="mapreduce的基本模型和处理思想">MapReduce的基本模型和处理思想</h3>

<h4 id="三大设计思想">三大设计思想</h4>

<ul>
  <li>
    <p><strong>分而治之：处理大数据</strong></p>

    <p>对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取<strong>分而治之</strong>的策略。</p>
  </li>
  <li>
    <p><strong>并行抽象模型：Mapper与Reducer</strong></p>

    <p>MPI等并行计算方法缺少高层并行编程模型，为了克服这一缺陷，MapReduce借鉴了Lisp函数式语言中的思想，用Map和Reduce两个函数提供了高层的并行编程抽象模型。</p>
  </li>
  <li>
    <p><strong>统一构架，隐藏系统层细节</strong></p>

    <p>MPI等并行计算方法缺少统一的计算框架支持，程序员需要考虑数据存储、划分、分发、结果收集、错误恢复等诸多细节；为此，MapReduce设计并提供了统一的计算框架，为程序员隐藏了绝大多数系统层面的处理细节。</p>
  </li>
</ul>

<h4 id="分而治之处理大数据">分而治之：处理大数据</h4>

<p>对相互间不具有计算依赖关系的大数据，实现并行最自然的办法就是采取<strong>分而治之</strong>的策略。</p>

<p><strong>不可分拆的计算任务或相互间有依赖关系的数据无法进行并行计算！</strong></p>

<p>并行化计算示例：</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925150338530.png" alt="image-20230925150338530" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925150344063.png" alt="image-20230925150344063" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925150400486.png" alt="image-20230925150400486" /></p>

<p>概念：</p>

<ul>
  <li>Master：负责划分和分配任务</li>
  <li>Worker：负责数据块计算</li>
</ul>

<h4 id="构建抽象模型mapper与reducer">构建抽象模型：Mapper与Reducer</h4>

<h5 id="map和reduce的工作方式">Map和Reduce的工作方式</h5>

<p>MapReduce借鉴了<strong>函数式设计语言Lisp</strong>的设计思想。</p>

<ul>
  <li>Lisp定义了可对列表元素进行整体处理的各种操作，如：
    <ul>
      <li>(add #(1 2 3 4) #(4 3 2 1)) 将产生结果： #(5 5 5 5)</li>
    </ul>
  </li>
  <li>
    <p>Lisp中也提供了类似于Map和Reduce的操作</p>

    <ul>
      <li>
        <p>如: (<strong>map</strong> ’vector #+#(1 2 3 4 5) #(10 11 12 13 14))</p>
      </li>
      <li>
        <p>通过定义加法map运算将2个向量相加产生结果#(11 13 15 17 19)</p>

        <p>(<strong>reduce</strong> #’+#(11 13 15 17 19)) 通过加法归并产生累加结果75</p>
      </li>
    </ul>
  </li>
</ul>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925151537434.png" alt="image-20230925151537434" /></p>

<p><strong>Map: 对一组数据元素进行某种重复式的处理</strong></p>

<p><strong>Reduce: 对Map的中间结果进行某种进一步的结果整理</strong></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925151556758.png" alt="image-20230925151556758" /></p>

<p>示例：</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925151149013.png" alt="image-20230925151149013" /></p>

<h5 id="map和reduce操作的抽象描述">Map和Reduce操作的抽象描述</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925151926611.png" alt="image-20230925151926611" /></p>

<h5 id="基于map和reduce的并行计算模型">基于Map和Reduce的并行计算模型</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925152049032.png" alt="image-20230925152049032" /></p>

<ul>
  <li>
    <p>各个map函数对所划分的数据并行处理，从不同的输入数据产生不同的中间结果输出。</p>
  </li>
  <li>
    <p>各个reduce也各自并行计算，各自负责处理不同的中间结果数据集合。</p>
  </li>
  <li>
    <p>进行reduce处理之前，必须等到所有的map函数做完，因此，在进入reduce前需要有一个同步障(barrier)；这个阶段也负责对map的中间结果数据进行收集整理(aggregation &amp; shuffle)处理，以便reduce更有效地计算最终结果。</p>
  </li>
  <li>
    <p>最终汇总所有reduce的输出结果即可获得最终结果。</p>
  </li>
</ul>

<h5 id="如何提供统一的计算框架">如何提供统一的计算框架</h5>

<p>MapReduce提供一个统一的计算框架，可完成：</p>

<ul>
  <li>
    <p>计算任务的划分和调度</p>
  </li>
  <li>
    <p>数据的分布存储和划分</p>
  </li>
  <li>
    <p>处理数据与计算任务的同步</p>
  </li>
  <li>
    <p>结果数据的收集整理(sorting, combining, partitioning…)</p>
  </li>
  <li>
    <p>系统通信、负载平衡、计算性能优化处理</p>
  </li>
  <li>
    <p>处理系统节点出错检测和失效恢复</p>
  </li>
</ul>

<h5 id="mapreduce最大的亮点">MapReduce最大的亮点</h5>

<p><strong>通过抽象模型和计算框架把需要做什么(what need to do)与具体怎么做(how to do)分开了</strong>，为程序员提供一个抽象和高层的编程接口和框架。</p>

<p>程序员仅需要关心其应用层的具体计算问题，<strong>仅需编写少量的处理应用本身计算问题的程序代码。</strong></p>

<p>如何具体完成这个并行计算任务所相关的诸多<strong>系统层细节被隐藏起来，交给计算框架去处理</strong>：从分布代码的执行，到大到数千小到单个节点集群的自动调度使用。</p>

<h5 id="mapreduce提供的主要功能">*MapReduce提供的主要功能</h5>

<p>MapReduce有四大主要功能：</p>

<ul>
  <li>
    <p><strong>数据划分和计算任务调度</strong></p>

    <p>提交的一个计算作业（Job)将被划分为很多个计算任务（Tasks)。</p>

    <p>任务调度功能主要负责为这些划分后的计算任务分配和调度计算结点（Map 结点或 Reduce 结点），同时负责监控这些结点的执行状态，以及 Map 结点执行的同步控制，也负责进行一些计算性能优化处理。例如，对最慢的计算任务采用多备份执行，选最快完成者作为结果。</p>
  </li>
  <li>
    <p><strong>数据/程序互定位</strong></p>

    <p>为了减少数据通信量，一个基本原则是本地化数据处理，即一个计算结点尽可能处理其本地磁盘上分布存储的数据，这实现了代码向数据的迁移。</p>

    <p>当无法进行这种本地化数据处理时，再寻找其他可用结点并将数据从网络上传送给该结点（数据向代码迁移)，但将尽可能从数据所在的本地机架上寻找可用结点以减少通信延迟。</p>
  </li>
  <li>
    <p><strong>出错处理</strong></p>

    <p>在以低端商用服务器构成的大规模 MapReduce 计算集群中，结点硬件（主机、兹盘、内存等）出错和软件有缺陷是常态。因此，MapReduce 架构需要能检测并隔离出错结点，并调度分配新的结点接管出错结点的计算任务。</p>
  </li>
  <li>
    <p><strong>分布式数据存储与文件管理</strong></p>

    <p>海量数据处理需要一个良好的分布数据存储和文件管理系统作为支撑，该系统能够把海量数据分布存储在各个结点的本地磁盘上，但保持整个数据在逻辑上成为一个完整的数据文件。</p>

    <p>为了提供数据存储容错机制，该系统还要提供数据块的多备份存储管理能力。</p>
  </li>
  <li>
    <p><strong>Combiner 和 Partitioner</strong></p>

    <p>为了减少数据通信开销，中间结果数据进入 Reduce 结点前需要进行合并（Combine）处理，即把具有同样主键的数据合并到一起避免重复传送。</p>

    <p>一个 Reduce 结点所处理的数据可能会来自多个 Map 结点，因此，Map 结点输出的中间结果需使用一定的策略进行适当的划分（Partition）处理，保证相关数据发送到同一个Reduce结点上。</p>
  </li>
</ul>

<h4 id="自动并行化并隐藏系统层细节">自动并行化并隐藏系统层细节</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925152844126.png" alt="image-20230925152844126" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925152848119.png" alt="image-20230925152848119" /></p>

<h3 id="mapreduce的主要思想和特征">MapReduce的主要思想和特征</h3>

<h4 id="向外横向扩展而非向上纵向扩展">向“外”横向扩展，而非向“上”纵向扩展</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153231150.png" alt="image-20230925153231150" /></p>

<h4 id="失效被认为是常态">失效被认为是常态</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153237534.png" alt="image-20230925153237534" /></p>

<h4 id="把处理向数据迁移">把处理向数据迁移</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153244540.png" alt="image-20230925153244540" /></p>

<h4 id="顺序处理数据避免随机访问数据">顺序处理数据、避免随机访问数据</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153251146.png" alt="image-20230925153251146" /></p>

<h4 id="为应用开发者隐藏系统层细节">为应用开发者隐藏系统层细节</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153328951.png" alt="image-20230925153328951" /></p>

<h4 id="平滑无缝的可扩展性">平滑无缝的可扩展性</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153337104.png" alt="image-20230925153337104" /></p>

<h2 id="ch4-google-mapreduce基本架构">CH4 Google MapReduce基本架构</h2>

<p>回顾一下Google的三驾马车：GFS、MapReduce、Bigtable</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153542156.png" alt="image-20230925153542156" /></p>

<h3 id="google-mapreduce的基本工作原理">Google MapReduce的基本工作原理</h3>

<h4 id="google-mapreduce并行处理的基本过程">Google MapReduce并行处理的基本过程</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153919653.png" alt="image-20230925153919653" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153926333.png" alt="image-20230925153926333" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153933224.png" alt="image-20230925153933224" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153937897.png" alt="image-20230925153937897" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925153942367.png" alt="image-20230925153942367" /></p>

<h4 id="失效处理">失效处理</h4>

<ul>
  <li>
    <p>主节点失效</p>

    <ul>
      <li>
        <p>主节点中会周期性地设置检查点(checkpoint)，检查整个计算作业的执行情况，一旦某个任务失效，可以从最近有效的检查点开始重新执行，避免从头开始计算的时间浪费。</p>
      </li>
      <li>
        <p>如果只有一个Master，它不太可能失败；因此，如果Master失败，将中止MapReduce计算。</p>
      </li>
    </ul>
  </li>
  <li>
    <p>工作节点失效</p>
    <ul>
      <li>工作节点失效是很普遍发生的，主节点会周期性地给工作节点发送检测命令，如果工作节点没有回应，这认为该工作节点失效，主节点将终止该工作节点的任务并把失效的任务重新调度到其它工作节点上重新执行。</li>
    </ul>
  </li>
</ul>

<h4 id="带宽优化">带宽优化</h4>

<ul>
  <li>
    <p>问题</p>

    <ul>
      <li>大量的键值对数据在传送给Reduce节点时会引起较大的通信带宽开销。</li>
    </ul>
  </li>
  <li>
    <p>解决方案</p>

    <ul>
      <li>每个Map节点处理完成的中间键值对将由combiner做一个合并压缩，即把那些键名相同的键值对归并为一个键名下的一组数值。</li>
    </ul>
  </li>
</ul>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925154222696.png" alt="image-20230925154222696" /></p>

<h4 id="计算优化">计算优化</h4>

<ul>
  <li><strong>问题</strong>
    <ul>
      <li>Reduce节点必须要等到所有Map节点计算结束才能开始执行，因此，如果有一个计算量大、或者由于某个问题导致很慢结束的Map节点，则会成为严重的“拖后腿者”。</li>
    </ul>
  </li>
  <li><strong>解决方案</strong></li>
  <li>把一个Map计算任务让多个Map节点同时做，取最快完成者的计算结果。</li>
</ul>

<h4 id="用数据分区解决数据相关性问题">用数据分区解决数据相关性问题</h4>

<ul>
  <li><strong>问题</strong>
    <ul>
      <li>一个Reduce节点上的计算数据可能会来自多个Map节点，因此，为了在进入Reduce节点计算之前，需要把属于一个Reduce节点的数据归并到一起。</li>
    </ul>
  </li>
  <li>
    <p><strong>解决方案</strong></p>

    <ul>
      <li>在Map阶段进行了Combining以后，可以根据一定的策略对Map输出的中间结果进行分区(partitioning)，这样即可解决以上数据相关性问题避免Reduce计算过程中的数据通信。</li>
    </ul>

    <p>例如：有一个巨大的数组，其最终结果需要排序，每个Map节点数据处理好后，为了避免在每个Reduce节点本地排序完成后还需要进行全局排序，我们可以使用一个分区策略如:(d%R)，d为数据大小，R为Reduce节点的个数，则可根据数据的大小将其划分到指定数据范围的Reduce节点上，每个Reduce将本地数据排好序后即为最终结果。</p>
  </li>
</ul>

<h3 id="分布式文件系统gfs的工作原理">分布式文件系统GFS的工作原理</h3>

<h4 id="gps是什么">GPS是什么？</h4>

<p>Google GFS是一个基于分布式集群的大型分布式文件系统，为MapReduce计算框架提供数据存储和数据可靠性支撑；</p>

<p>GFS是一个构建在分布节点本地文件系统之上的一个逻辑上文件系统，它将数据存储在物理上分布的每个节点上，但通过GFS将整个数据形成一个逻辑上整体的文件。</p>

<h4 id="google-gfs的基本设计原则">Google GFS的基本设计原则</h4>

<ul>
  <li><strong>廉价本地磁盘分布存储</strong>
    <ul>
      <li>各节点本地分布式存储数据，优点是不需要采用价格较贵的集中式磁盘阵列，容量可随节点数增加自动增加</li>
    </ul>
  </li>
  <li><strong>多数据自动备份解决可靠性</strong>
    <ul>
      <li>采用廉价的普通磁盘，把磁盘数据出错视为常态，用自动多数据备份存储解决数据存储可靠性问题</li>
    </ul>
  </li>
  <li><strong>为上层的MapReduce计算框架提供支撑</strong>
    <ul>
      <li>GFS作为向上层MapReduce执行框架的底层数据存储支撑，负责处理所有的数据自动存储和容错处理，因而上层框架不需要考虑底层的数据存储和数据容错问题</li>
    </ul>
  </li>
</ul>

<h4 id="google-gfs的基本架构和工作原理">Google GFS的基本架构和工作原理</h4>

<h5 id="基本架构">基本架构</h5>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925155258227.png" alt="image-20230925155258227" /></p>

<h6 id="gfs-master">GFS Master</h6>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925155343542.png" alt="image-20230925155343542" /></p>

<h6 id="gfs-chunkserver">GFS ChunkServer</h6>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925155418509.png" alt="image-20230925155418509" /></p>

<h5 id="工作原理数据访问工作过程">工作原理：数据访问工作过程</h5>

<ol>
  <li>
    <p>在程序运行前，数据已经存储在GFS文件系统中；程序运行时应用程序会告诉GFS Server所要访问的文件名或者数据块索引是什么。</p>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925143810439.png" alt="image-20230925143810439" /></p>
  </li>
  <li>
    <p>GFS Server根据文件名和数据块索引在其文件目录空间中查找和定位该文件或数据块，找出数据块具体在哪些ChunkServer上；将这些位置信息回送给应用程序。</p>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925143831698.png" alt="image-20230925143831698" /></p>
  </li>
  <li>
    <p>应用程序根据GFS Server返回的具体Chunk数据块位置信息，直接访问相应的ChunkServer。</p>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925143855037.png" alt="image-20230925143855037" /></p>
  </li>
  <li>
    <p>应用程序根据GFS Server返回的具体Chunk数据块位置信息直接读取指定位置的数据进行计算处理。</p>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925143908898.png" alt="image-20230925143908898" /></p>
  </li>
</ol>

<p>以上过程的特点是：应用程序访问具体数据的时候不需要经过GFS Master，避免了Master成为访问性能瓶颈；另一方面，由于大量数据会存储在不同的ChunkServer中，应用可实现并发访问。</p>

<h5 id="gfs的系统管理技术">GFS的系统管理技术</h5>

<ul>
  <li>
    <p><strong>大规模集群安装技术</strong>：如何在一个成千上万个节点的集群上迅速部署GFS，升级管理和维护等。</p>
  </li>
  <li>
    <p>故障检测技术：GFS是构建在不可靠的廉价计算机之上的文件系统，节点数多，故障频繁，如何快速检测、定位、恢复或隔离故障节点。</p>
  </li>
  <li>
    <p><strong>节点动态加入技术</strong>：当新的节点加入时，需要能自动安装和部署GFS。</p>
  </li>
  <li>
    <p><strong>节能技术</strong>：服务器的耗电成本大于购买成本，Google为每个节点服务器配置了蓄电池替代UPS，大大节省了能耗。</p>
  </li>
</ul>

<h3 id="分布式结构化数据表bigtable的基本工作原理">分布式结构化数据表BigTable的基本工作原理</h3>

<h4 id="bigtable的基本作用和设计思想">BigTable的基本作用和设计思想</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160241919.png" alt="image-20230925160241919" /></p>

<p>GPS是一个分布式文件管理系统，不适合用来存储和管理结构化数据。因此在GFS之上又设计了一个结构化数据存储和访问管理系统—BigTable，为应用程序提供比单纯的文件系统更方便、更高层的数据操作能力，同时提供了一定粒度的结构化数据操作能力。</p>

<p><strong>但是它结构化粒度低，没有事务处理能力，因此不是真正意义上的数据库。</strong></p>

<h4 id="bigtable的设计动机和目标">BigTable的设计动机和目标</h4>

<ul>
  <li>
    <p>广泛的适用性：为一系列服务和应用而设计的数据存储系统，可满足对不同类型数据的存储和操作需求</p>
  </li>
  <li>
    <p>很强的可扩展性：根据需要可随时自动加入或撤销服务器节点</p>
  </li>
  <li>
    <p>高吞吐量数据访问：提供P级数据存储能力，每秒数百万次的访问请求</p>
  </li>
  <li>
    <p>高可用性和容错性：保证系统在各种情况下都能正常运转，服务不中断</p>
  </li>
  <li>
    <p>自动管理能力：自动加入和撤销服务器，自动负载平衡</p>
  </li>
  <li>
    <p>简单性：系统设计尽量简单以减少复杂性和出错率</p>
  </li>
</ul>

<h4 id="bigtable数据模型">BigTable数据模型</h4>

<p>BigTable主要是一个分布式多维表，表中的数据通过：</p>

<ul>
  <li>
    <p>一个行关键字（row key）</p>
  </li>
  <li>
    <p>一个列关键字（column key）</p>
  </li>
  <li>
    <p>一个时间戳（timestamp）</p>
  </li>
</ul>

<p>进行索引和查询定位的。</p>

<p>BigTable对存储在表中的数据不做任何解释，一律视为字节串，具体数据结构的实现由用户自行定义。</p>

<p>BigTable查询模型</p>

<ul>
  <li>
    <p>(row:string, column:string,time:int64)-&gt;结果数据字节串</p>
  </li>
  <li>
    <p>支持查询、插入和删除操作</p>
  </li>
</ul>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925145049058.png" alt="image-20230925145049058" /></p>

<p>BigTable数据存储格式：</p>

<ul>
  <li>
    <p>行(Row):大小不超过64KB的任意字符串。表中的数据都是根据行关键字进行排序的。</p>

    <p>com.cnn.www就是一个行关键字，指明一行存储数据。URL地址倒排好处是：1)同一地址的网页将被存储在表中连续的位置，便于查找；2)倒排便于数据压缩，可大幅提高数据压缩率。</p>
  </li>
  <li>
    <p>子表(Tablet)：一个大表可能太大，不利于存储管理，将在水平方向上被分为多个子表。</p>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925145235130.png" alt="image-20230925145235130" /></p>
  </li>
  <li>
    <p>列(Column): BigTable将列关键字组织成为“列族”(column family)，每个族中的数据属于同一类别，如anchor是一个列族，其下可有不同的表示一个个超链的列关键字。一个列族下的数据会被压缩在一起存放（按列存放）。因此，一个列关键字可表示为： 族名：列名(family:qualifier)</p>

    <p>content、anchor都是族名；而cnnsi.com和my.look.ca则是anchor族中的列名。</p>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925145449795.png" alt="image-20230925145449795" /></p>
  </li>
  <li>
    <p>时间戳(time stamp):很多时候同一个URL的网页会不断更新，而Google需要保存不同时间的网页数据，因此需要使用时间戳来加以区分。</p>

    <p>为了简化不同版本的数据管理，BigTable提供给了两种设置：</p>

    <ul>
      <li>保留最近的n个版本数据</li>
      <li>保留限定时间内的所有不同版本数据</li>
    </ul>

    <p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925145607139.png" alt="image-20230925145607139" /></p>
  </li>
</ul>

<h4 id="bigtable基本架构">BigTable基本架构</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160602703.png" alt="image-20230925160602703" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160613301.png" alt="image-20230925160613301" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160617337.png" alt="image-20230925160617337" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160621832.png" alt="image-20230925160621832" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160703085.png" alt="image-20230925160703085" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/img/image-20230925160707450.png" alt="image-20230925160707450" /></p>

<h2 id="ch5-hadoop基本架构">CH5 Hadoop基本架构</h2>

<h3 id="hadoop平台的基本组成与生态系统">Hadoop平台的基本组成与生态系统</h3>

<p>Hadoop是一个开源分布式计算平台，为用户提供了系统底层细节透明的分布式基础架构。</p>

<p>Hadoop是基于Java语言开发的，具有很好的跨平台特性，并且可以部署在廉价的计算机集群中。</p>

<p>Hadoop的核心是分布式文件系统HDFS（Hadoop Distributed File System）和MapReduce。</p>

<h4 id="hadoop特性">Hadoop特性</h4>

<p>可靠、高效、可伸缩</p>

<ul>
  <li>高可靠性</li>
  <li>高效性</li>
  <li>高可扩展性</li>
  <li>高容错性</li>
  <li>成本低</li>
  <li>
    <p>运行在Linux平台上</p>
  </li>
  <li>支持多种编程语言</li>
</ul>

<h4 id="基本组成与生态系统">基本组成与生态系统</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013082107625.png" alt="image-20231013082107625" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013082135903.png" alt="image-20231013082135903" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013082147800.png" alt="image-20231013082147800" /></p>

<h3 id="分布式文件系统hdfs">分布式文件系统HDFS</h3>

<p>HDFS模仿Google GFS设计实现。</p>

<h4 id="hdfs基本特征">HDFS基本特征</h4>

<ul>
  <li>存储极大数目的信息/极大的单个文件</li>
  <li>提供数据的高可靠性和容错能力</li>
  <li>提供对数据的快速访问</li>
  <li>……</li>
</ul>

<h4 id="hdfs基本构架">HDFS基本构架</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013082637528.png" alt="image-20231013082637528" /></p>

<p>HDFS的主要组件有NameNode，DataNode。</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013082758182.png" alt="image-20231013082758182" /></p>

<p>用一个表来直观展示它们的功能：</p>

<table>
  <thead>
    <tr>
      <th>NameNode</th>
      <th>DataNode</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>存储元数据</td>
      <td>存储文件内容</td>
    </tr>
    <tr>
      <td>元数据保存在内存中</td>
      <td>文件内容保存在磁盘</td>
    </tr>
    <tr>
      <td>保存文件，block，datanode之间的映射关系</td>
      <td>维护了block id到datanode本地文件的映射关系</td>
    </tr>
  </tbody>
</table>

<p>NameNode充当了HDFS的主节点，负责元数据管理，DataNode充当了多个从节点，负责数据的存储和处理，而SecondaryNameNode是辅助节点，用于辅助主要的NameNode在元数据管理方面。这种架构模式有助于实现HDFS的可伸缩性、容错性和负载均衡。</p>

<h5 id="namenode">NameNode</h5>

<p>这是NameNode的目录结构：</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231009234817222.png" alt="image-20231009234817222" /></p>

<p>在HDFS中，名称节点（NameNode）负责管理分布式文件系统的命名空间（Namespace），记录了每个文件中各个块所在的数据节点的位置信息，<strong>保存了两个核心的数据结构，即FsImage和EditLog。</strong>其中：</p>

<ul>
  <li>
    <p><strong>FsImage用于维护文件系统树以及文件树中所有的文件和文件夹的元数据</strong>。</p>

    <p>FsImage文件包含文件系统中所有目录和文件inode的序列化形式。每个inode是一个文件或目录的元数据的内部表示。</p>
  </li>
  <li>
    <p><strong>操作日志文件EditLog中记录了所有针对文件的创建、删除、重命名等操作</strong></p>
  </li>
</ul>

<h6 id="启动过程">启动过程</h6>

<ul>
  <li>在名称节点启动的时候，它会将FsImage文件中的内容加载到内存中，之后再执行EditLog文件中的各项操作，使得内存中的元数据和实际的同步，存在内存中的元数据支持客户端的读操作。</li>
  <li>一旦在内存中成功建立文件系统元数据的映射，则创建一个新的FsImage文件和一个空的EditLog文件。</li>
  <li>名称节点起来之后，HDFS中的更新操作会重新写到EditLog文件中，因为FsImage文件一般都很大（GB级别的很常见），如果所有的更新操作都往FsImage文件中添加，这样会导致系统运行的十分缓慢，但是，如果往EditLog文件里面写就不会这样，因为EditLog 要小很多。每次执行写操作之后，且在向客户端发送成功代码之前，edits文件都需要同步更新。</li>
</ul>

<h6 id="名称节点运行期间editlog不断变大的问题">名称节点运行期间EditLog不断变大的问题</h6>

<p><strong>在名称节点运行期间，HDFS的所有更新操作都是直接写到EditLog中，久而久之， EditLog文件将会变得很大。</strong></p>

<p>虽然这对名称节点运行时候是没有什么明显影响的，但是，当名称节点重启的时候，名称节点需要先将FsImage里面的所有内容映像到内存中，然后再一条一条地执行EditLog中的记录，当EditLog文件非常大的时候，会导致名称节点启动操作非常慢，而在这段时间内HDFS系统处于安全模式，一直无法对外提供写操作，影响了用户的使用。</p>

<h5 id="secondarynamenode">SecondaryNameNode</h5>

<p>SecondaryNameNode本质上是NameNode的备份，NameNode也可以看作是FirstNameNode。</p>

<p>SecondaryNameNode的目录结构：</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231009235420268.png" alt="image-20231009235420268" /></p>

<p>SecondaryNameNode是HDFS架构中的一个组成部分，<strong>它是用来保存名称节点（NameNode）中对HDFS元数据信息的备份</strong>，并减少名称节点重启的时间。SecondaryNameNode一般是单独运行在一台机器上。</p>

<p>工作流程：</p>

<ul>
  <li>SecondaryNameNode会定期和NameNode通信</li>
  <li>从NameNode上获取到FsImage和EditLog文件，并下载到本地的相应目录下</li>
  <li>执行EditLog和FsImage文件合并</li>
  <li>将新的FsImage文件发送到NameNode节点上</li>
  <li>NameNode使用新的FsImage和EditLog（缩小了）</li>
</ul>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231009235755198.png" alt="image-20231009235755198" /></p>

<p>第二名称节点用途：</p>

<ul>
  <li>不是热备份</li>
  <li><strong>主要是防止日志文件EditLog过大，导致名称节点失败恢复时消耗过多时间</strong>（主要）</li>
  <li>附带起到冷备份功能</li>
</ul>

<h4 id="hdfs命名空间管理">HDFS命名空间管理</h4>

<p>HDFS的命名空间包含目录、文件和块。</p>

<p>在HDFS1.0体系结构中，在整个HDFS集群中只有一个命名空间，并且只有唯一一个名称节点，该节点负责对这个命名空间进行管理。</p>

<p>HDFS使用的是传统的分级文件体系，因此，用户可以像使用普通文件系统一样，创建、删除目录和文件，在目录间转移文件，重命名文件等。</p>

<h4 id="hdfs通信协议">HDFS通信协议</h4>

<p>所有的HDFS通信协议都是构建在TCP/IP协议基础之上的。</p>

<p>客户端通过一个可配置的端口向名称节点主动发起TCP连接，并使用客户端协议与名称节点进行交互。</p>

<p>名称节点和数据节点之间则使用数据节点协议进行交互。</p>

<p>客户端与数据节点的交互是通过RPC（Remote Procedure Call）来实现的。在设计上，名称节点不会主动发起RPC，而是响应来自客户端和数据节点的RPC请求。</p>

<h4 id="hdfs数据存取">HDFS数据存取</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084002400.png" alt="image-20231013084002400" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084040967.png" alt="image-20231013084040967" /></p>

<h5 id="数据存放">数据存放</h5>

<ul>
  <li>第一个副本：放置在上传文件的数据节点；如果是集群外提交，则随机挑选一台磁盘不太满、CPU不太忙的节点</li>
  <li>第二个副本：放置在与第一个副本不同的机架的节点上</li>
  <li>第三个副本：与第一个副本相同机架的其他节点上</li>
  <li>更多副本：随机节点</li>
</ul>

<h5 id="数据读取">数据读取</h5>

<p>HDFS提供了一个API可以确定一个数据节点所属的机架ID，客户端也可以调用API获取自己所属的机架ID（Rack Awareness）。</p>

<p>当客户端读取数据时，从名称节点获得数据块不同副本的存放位置列表，列表中包含了副本所在的数据节点，可以调用API来确定客户端和这些数据节点所属的机架ID，<strong>当发现某个数据块副本对应的机架ID和客户端对应的机架ID相同时，就优先选择该副本读取数据</strong>，如果没有发现，就随机选择一个副本读取数据。</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084406753.png" alt="image-20231013084406753" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084418638.png" alt="image-20231013084418638" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084651717.png" alt="image-20231013084651717" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084659657.png" alt="image-20231013084659657" /></p>

<h4 id="hdfs可靠性与出错恢复">HDFS可靠性与出错恢复</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013084720574.png" alt="image-20231013084720574" /></p>

<h5 id="namenode出错">NameNode出错</h5>

<h6 id="备份secondarynamenode">备份（SecondaryNameNode）</h6>

<p>对于NameNode，HDFS设置了备份机制，把这些核心文件同步复制到备份服务器SecondaryNameNode上。当名称节点出错时，就可以根据备份服务器SecondaryNameNode中的FsImage和Editlog数据进行恢复。</p>

<h6 id="高可用性ha">高可用性（HA）</h6>

<p>HDFS HA（High Availability）是为了解决<strong>单点故障</strong>问题。</p>

<p>在Hadoop 2.x以后的版本中，HA集群设置两个名称节点，活跃（Active）和待命（Standby）。两种名称节点的状态同步，可以借助于一个共享存储系统来实现。一旦活跃名称节点出现故障，就可以立即切换到待命名称节点。</p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231010000905713.png" alt="image-20231010000905713" /></p>

<h5 id="datanode出错">DataNode出错</h5>

<h6 id="数据复制">数据复制</h6>

<p>HDFS会将每个文件的数据块在多个DataNode上进行复制存储，默认情况下，每个数据块会有三个副本。这样，即使某个DataNode发生故障，文件的数据仍然可以从其他DataNode上的副本中访问到。</p>

<h6 id="心跳检测">心跳检测</h6>

<p>NameNode会定期向所有DataNode发送心跳信号，如果一段时间内没有收到某个DataNode的心跳信号，NameNode就会认为这个DataNode发生了故障，然后会将这个DataNode上的数据块的副本重新分配到其他DataNode上，以保证数据的可用性和可靠性。</p>

<h6 id="数据一致性和校验和checksum">数据一致性和校验和（Checksum）</h6>

<p>HDFS通过使用校验和来保证数据的一致性。</p>

<p>当数据写入HDFS时，会在客户端计算每个数据块的校验和，并将校验和和数据块一起存储在DataNode上。</p>

<p>当数据从HDFS读取时，会在客户端重新计算数据块的校验和，并与存储在DataNode上的校验和进行比较，如果两者不一致，说明数据在传输过程中可能发生了错误，客户端可以请求从其他DataNode上读取数据块的其他副本。</p>

<p>通过这种方式，HDFS可以在一定程度上保证数据的一致性和可靠性。</p>

<h5 id="hdfs纠删码ec">HDFS纠删码（EC）</h5>

<p>EC，是一种编码容错技术。最早用于通信行业，数据传输中的数据恢复。它通过对数据进行分块，然后计算出校验数据，使得各个部分的数据产生关联性。<strong>当一部分数据块丢失时，可以通过剩余的数据块和校验块计算出丢失的数据块。</strong></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013085131005.png" alt="image-20231013085131005" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013085142838.png" alt="image-20231013085142838" /></p>

<ul>
  <li>优势：节约存储空间</li>
  <li>劣势：
    <ul>
      <li>网络带宽的消耗，因为数据恢复需要去读其他的数据块和校验块</li>
      <li>进行编码，解码计算需要消耗CPU资源</li>
    </ul>
  </li>
  <li>最好的选择是用于冷数据集群
    <ul>
      <li>冷数据集群往往有大量的长期没有被访问的数据，体量确实很大，采用EC技术，可以大大减少副本数</li>
      <li>冷数据集群基本稳定，耗资源量少，所以一旦进行数据恢复，将不会对集群造成大的影响</li>
    </ul>
  </li>
</ul>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013085336249.png" alt="image-20231013085336249" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013085349401.png" alt="image-20231013085349401" /></p>

<h3 id="yarn新一代hadoop架构">YARN：新一代Hadoop架构</h3>

<p>第二代Hadoop引入了YARN作为资源管理工具。</p>

<h4 id="理念">理念</h4>

<p><strong>YARN的目标就是实现“一个集群多个框架” ，即在一个集群上部署一个统一的资源调度管理框架YARN，在YARN之上可以部署其他各种计算框架。</strong></p>

<p>YARN的优势在于：</p>

<ul>
  <li>由YARN为这些计算框架提供统一的资源调度管理服务。</li>
  <li>且能够根据各种计算框架的负载需求，调整各自占用的资源，实现集群资源共享和资源弹性收缩。</li>
  <li>可以实现一个集群上的不同应用负载混搭，有效提高了集群的利用率。</li>
  <li>不同计算框架可以共享底层存储，避免了数据集跨集群移动。</li>
</ul>

<p>YARN实现了：</p>

<ul>
  <li>更高的集群利用率，一个框架未使用的资源可由另一个框架进行使用，充分的避免资源浪费。</li>
  <li>在新的Yarn中，通过加入ApplicationMaster是一个可变更的部分，用户可以针对不同的编程模型编写自己的ApplicationMaster，让更多的编程模型运行在Hadoop集群中。</li>
  <li>在上一版框架中，JobTracker一个很大的负担就是监控Job的tasks运行情况，现在，这个部分下放到了ApplicationMaster中它的思路主要是：将原来的JobTracker三大功能拆分。</li>
</ul>

<h4 id="实现方式">实现方式</h4>

<ul>
  <li>Yet Another Resource Negotiator：另一种资源协调者。它是一个<strong>通用资源管理系统，可为上层应用提供统一的资源管理和调度</strong>，它的引入为集群在利用率、资源统一管理和数据共享等方面带来了巨大好处。</li>
  <li>ResourceManager (RM）<strong>全局管理所有应用程序计算资源的分配</strong>，每个应用的ApplicationMaster (<em>AM</em>)负责相应的调度和协调。</li>
  <li>一个应用程序无非是一个单独的传统的 MapReduce 任务或者是一个 DAG（有向无环图）任务。ResourceManager和每一台机器的节点管理服务器能够管理用户在那台机器上的进程并能对计算进行组织。</li>
</ul>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231010002116788.png" alt="image-20231010002116788" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231010002127644.png" alt="image-20231010002127644" /></p>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231010002153685.png" alt="image-20231010002153685" /></p>

<h4 id="hadoop-mapreduce基本工作过程">Hadoop MapReduce基本工作过程</h4>

<p><img src="https://repo-for-md.oss-cn-beijing.aliyuncs.com/uPic/image-20231013085527475.png" alt="image-20231013085527475" /></p>


    </div>

</article>
<div class="post-nav"><span></span><a class="next" href="/lecturenotes/2023/10/08/CH3-%E7%BB%84%E5%90%88%E9%80%BB%E8%BE%91%E7%94%B5%E8%B7%AF.html" title="CH3 组合逻辑电路">CH3 组合逻辑电路</a></div><div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/research/notes/2023/11/19/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80.html" title="强化学习基础">
            强化学习基础<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li><li class="">
          <a class="post-link" href="/csnotes/2024/02/11/CH5-%E8%A1%A8%E8%BE%BE%E5%BC%8F.html" title="CH5 表达式">
            CH5 表达式<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li><li class="">
          <a class="post-link" href="/csnotes/2024/02/11/CH11-%E4%BD%BF%E7%94%A8%E7%B1%BB.html" title="CH11 使用类">
            CH11 使用类<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li><li class="">
          <a class="post-link" href="/csnotes/2024/02/11/CH9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4.html" title="CH9 内存模型和名称空间">
            CH9 内存模型和名称空间<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li></ul>
    </div><div class="post-comments"></div></section>
</div>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner"><div>Unpublished Work <span class="copyleft">&copy;</span> 2017-2024 DragonK</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></div>
    </div>
  </div>
</footer>
</body>
</html>
