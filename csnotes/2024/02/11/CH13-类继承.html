<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="google-translate-customization" content="108d9124921d80c3-80e20d618ff053c8-g4f02ec6f3dba68b7-c"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>CH13 类继承 | Step far.</title>
<meta name="generator" content="Jekyll v3.9.5" />
<meta property="og:title" content="CH13 类继承" />
<meta name="author" content="DragonK" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="CH13 类继承 面向对象编程的主要目的之是提供可重用的代码。 C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。 下面是可以通过继承完成的一些工作： 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。 可以给类添加数据。例如，对于字符串类，可以派生出一个类，一并添加指定字符串显示颜色的数据成员。 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的Passenger类，可以派生出提供更高级别服务的FirstClassPassenger类。 简单的基类及其派生 class RatedPlayer: public TableTennisPlayer { ... } 冒号指出RatedPlayer类的基类是TableTennisplayer类。 public表明TableTennisPlayer是个公有基类，这被称为公有派生。 使用公有派生，基类的公有成员将成为派生类的公有成员：基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。 上述代码完成了哪些工作呢？Ratedplayer对象将具有以下特征： 派生类对象存储了基类的数据成员（派生类继承了基类的实现）： 派生类对象可以使用基类的方法（派生类继承了基类的接口）。 需要在继承特性中添加什么呢？ 派生类需要自己的构造函数。 派生类可以根据需要添加额外的数据成员和成员函数。 构造函数：访问权限的考虑 派生类不能直接访问基类的私有成员，而必须通过基类提供的公有方法进行访问。 创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建。 上面所说的工作由成员初始化列表语法来完成。 显式的： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer(fn,ln,ht) { rating=r; } 隐式的： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht) { rating=r; } //这种省略成员初始化列表实际上等价于： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer() { rating=r; } 这是因为：必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数。 所以，在任何情况下最好提供一个无参数的默认构造函数！ 如果传入参数是类引用： RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer&amp; tp):TableTennisPlayer(tp) { rating=r; } 由王tp的类型为TableTennisPlayer&amp;，因此将调用基类的复制构造函数（这个浅复制是可以接受的，因为没有使用new）。 基类没有定义复制构造函数，如果需要使用复制构造函数但又没有定义，编译器将自动生成一个。 此外，可以把基类也看做派生类的成员之一，因为初始化派生类时要先初始化基类，而这一步的形式和初始化派生类成员是一样的。 RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer &amp; tp):TableTennisPlayer(tp),rating(r) { ... } 使用派生类 要使用派生类，程序必须要能够问基类声明。 可以将这两种类的声明置于同一个头文件中，也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。 派生类和基类之间的关系 派生类与基类之间有一些特殊关系： 派生类对象可以使用基类的非私有方法 基类指针可以在不进行显式类型转换的情况下指向派生类对象（只能单向） 基类引用可以在不进行显式类型转换的情况下引用派生类对象（只能单向） Ratedplayer rplayer1(1140,&quot;Mallory&quot;,&quot;Duck&quot;,true); TableTennisplayer&amp; rt=rplayer; TableTennisplayer* pt=&amp;rplayer; rt.Name();//invoke Name()with reference pt-&gt;Name();//invoke Name()with pointer 然而： 基类指针或引用只能用于调用基类方法。因此，不能使用rt或pt来调用派生类的ResetRanking方法。 不可以将基类对象和地址赋给派生类引用和指针。 对于形参为指向基类的指针的函数，它可以使用基类对象的地址或派生类对象的地址作为实参。 引用兼容性属性也能够将基类对象初始化为派生类对象： RatedPlayer olaf1(1840,&quot;Olaf&quot;,&quot;Loaf&quot;,true); TableTennisPlayer olaf2(olaf1); 理论上，需要这样的构造函数原型来初始化olaf2： TableTennisPlayer(const RatedPlayer &amp;); //doesn&#39;t exist 类定义中没有这样的构造函数，但存在隐式复制构造函数： TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor 由于可以发生从派生类到基类的隐式转换，所以这个复制构造函数能够接受派生类引用作为参数。 对于赋值运算符也是一样的： TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor RatedPlayer olaf1(1840,&quot;Olaf&quot;,&quot;Loaf&quot;,true); TableTennisPlayer winner; winner=olaf; //assign derived to base object 存在隐式重载赋值运算符： TableTennisPlayer &amp; operator=(const TableTennisPlayer &amp;)const; 在上面的部分中，只有派生类的基类部分会赋值给基类。 is-a继承 一般而言，认为普通公有继承只建立is-a，或者说is-a-kind-of关系。 例如，可以从Fruit派生出Banana。 公有继承不能实现以下关系： is-like-a关系，不能采取明喻。人们通常说律师就像鲨鱼，但律师并不是鲨鱼。所以不能从Shark派生出Lawyer类。 is-implemented-as-a，作为…来实现关系。例如，可以使用数组来实现栈，但不能从Array类派生出Stack类。 uses-a关系。计算机可以使用打印机，但是不能从Computer派生出Printer类。 多态公有继承 多态公有继承指的是一个类公有地继承另一个类，并重写基类的虚函数，从而实现多态行为。主要涉及到两个部分：公有继承和多态。 多态（Polymorphism）是面向对象编程的一个重要特性，它允许我们通过基类的指针或引用来操作派生类对象。 在C++中，多态是通过虚函数（virtual functions）来实现的。如果一个基类定义了一个虚函数，那么派生类可以重写（override）这个函数。然后，我们可以通过基类的指针或引用来调用这个函数，而实际执行的是派生类版本的函数。这就是所谓的动态绑定或后期绑定（late binding）。 有两种机制可以用于实现多态公有继承： 在派生类中重新定义基类的方法 使用虚方法 class Brass { private: std::string fullName; long acctNum; double balance; public: Brass(const std::string&amp;s= &quot;Nullbody&quot;,long an =-1, double bal=0.0); void Deposit(double amt); virtual void Withdraw(double amt); double Balance() const; virtual void ViewAcct() const; virtual ~Brass(){} }; class BrassPlus:public Brass { private: double maxLoan; double rate; double owesBank; public: BrassPlus(const std::string &amp; s =&quot;Nullbody&quot;,long an=-1, double bal=0.0,double ml=500, double r=0.11125); BrassPlus(const Brass &amp; ba,double ml= 500, double r=0.11125); virtual void ViewAcct()const; virtual void Withdraw(double amt); void ResetMax(double m){maxLoan=m;} void ResetRate(double r){rate=r;} void ResetOwes(){owesBank=0;} }; Withdraw()函数有2个版本，这说明基类和派生类在这两个函数中的行为不同（对于在两个类中行为相同的方法，则只在基类中声明）。 如果方法是通过引用或指针而不是对象调用的，关键字Virtual将确定使用哪一种方法。 如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法。 Brass dom (&quot;Dominic-Banker&quot;,11224,4183.45) Brassplus dot (&quot;Dorothy Banker&quot;,12118,2592.00); Brass &amp; bl_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct();//use Brass::ViewAcct() b2_ref.ViewAcct();//use Brass::ViewAcct() 如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。 Brass dom (&quot;Dominic-Banker&quot;,11224,4183.45) Brassplus dot (&quot;Dorothy Banker&quot;,12118,2592.00); Brass &amp; bl_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct();//use Brass::ViewAcct() b2_ref.ViewAcct();//use Brassplus::ViewAcct() 方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。 也可以在派生类中使用virtual来强调这一事实。（不然程序员很可能会忘记） 类实现 关键字virtual只用于类声明的方法原型中，而不允许在方法文件中实现中使用！ 代码必须使用作用域解析运算符（特别是当派生类的重载函数中调用了基类的同名函数时），否则发生递归调用。 基类与派生类的数组 假设要同时管理Brass和BrassPlus账户，如果能使用同一个数组来保存Brsss和BrassPlus对象，将很有帮助。 但这是不可能的，因为数组中所有元素的类型必须相同，而Brass和BrassPlus是不同的类型。 然而，可以创建指向Brass的指针数组。由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。 多态真是美妙！ 静态联编和动态联编 程序调用函数时，将使用哪个可执行代码块呢？ 编译器将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。 在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。 生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。 指针、引用类型的兼容 BrassPlus dilly(&quot;Annie Dill&quot;,493222,2000); Brass* pb=&amp;dilly; Brass&amp; pb=dilly; 将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。 向上强制转换是可传递的，也就是说，如果从BrassPlus派生出BrassPlusPlus类，则Brass指针或引用可以引用Brass对象、BrassPlus对象或BrassPlusPlus对象。 相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。 如果不使用显式类型转换，则向下强制转换是不允许的。 通常不推荐这么做，唯一有可能的情况是：本来这个基类指针指向的就是派生类对象，再将其转换成派生类指针。 class Base { public: virtual ~Base() {} }; class Derived : public Base { public: void sayHello() { std::cout &lt;&lt; &quot;Hello from Derived!&quot; &lt;&lt; std::endl; } }; int main() { Base* b = new Derived(); // Upcasting // Downcasting Derived* d = (Derived*)(b); if (d) { // Check if the downcasting was successful d-&gt;sayHello(); // Now it&#39;s safe to call } delete b; return 0; } 两种类型的联编 为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，所以会有额外处理开销。所以使用静态联编效率更高。 如果派生类不重新定义基类的任何方法，就不需要使用动态联编。 虚函数的工作原理 通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。 隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table, vtbl）。（究竟有多少级指针呢？） 虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。 如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址。 如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。 再整理一下概念： 虚函数表（vtable）：当一个类中声明了虚函数，编译器会为这个类生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是指向类的虚函数的指针。每个类的虚函数表是唯一的，所有该类的对象都共享同一个虚函数表。 虚指针（vptr）：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个虚指针指向该类的虚函数表。如果有派生类对象，那么派生类对象的虚指针会指向派生类的虚函数表。 动态绑定：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后在虚函数表中查找并调用相应的虚函数。这个过程是在运行时进行的，因此称为动态绑定。 使用虚函数时，在内存和执行速度方面有一定的成本，包括： 每个对象都将增大，增大量为存储地址的空间。 对于每个类，编译器都创建一个虚函数地址表（数组）。 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。 有关虚函数注意事项 构造函数 构造函数不能是虚函数。实际上，这没有意义 创建派生类对象时，将调用派生类的构造函数，然后派生类的构造函数会调用基类的一个构造函数。 也就是说派生类不继承基类的构造函数。 析构函数 通常应给基类提供一个虚析构函数（这样派生类的析构函数自动也成为虚的），即使它并不需要析构函数。 考虑这样的场景： Employee * pe=new Singer; ... delete pe; 如果析构函数不是虚的，那么delete只会释放基类部分的内存（会引发问题！）。 如果析构函数是虚的，那么先调用派生类的析构，再自动调用基类的析构函数（这是声明周期管理的特性）。 友元 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。 如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。 没有重新定义 如果派生类没有重新定义函数，将使用该函数的基类版本。 如果派生类位于派生链中，则将使用最新的虚函数版本（虚函数不是不能用！）。 也就是说从某个类开始声明了虚函数，那么后面所有的版本无论是否重新定义，都自动成为虚函数。 例外的情况是基类版本是隐藏的（稍后将介绍） 重新定义将隐藏方法 如果派生类中的函数和基类中的虚函数有相同的名称和参数列表，那么派生类中的函数将覆盖（也称为重写）基类中的虚函数，这是虚函数的正常使用方式。 如果派生类中的函数和基类中的函数具有相同的名称，但参数列表不同，那么派生类中的函数将会隐藏基类中所有同名的函数，无论参数列表是否相同。 如果你想在派生类中使用和基类中同名但参数列表不同的函数，而不隐藏基类中的函数，你可以使用using声明。 这引出了两条经验规则： 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。（也即：可以允许返回类型不同的重载） 这种允许返回类型随类类型的变化而变化的特性被称为返回类型协变（covariance of return type）。 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。 访问控制：protected private和protected之间的区别只有在基类派生的类中才会表现出来。 派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。 抽象基类（ABC） C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0，参见： class BaseEllipse { public: virtual double Area() const=0; } 纯虚函数的理念是：包含纯虚函数的类只用作基类。 当类声明中包含纯虚函数时，则不能创建该类的对象。 这里的方法Area()没有定义，但C++甚至允许纯虚函数有定义： //myclass.h void Move(int nx,ny)=0; //myclass.cpp void BaseEllipse::Move(int nx,ny){x=nx;y=ny;} ... 为什么不干脆直接将派生类们分开定义？因为它们还是有共同之处的，所以这种解决办法效率不高，也从逻辑上比较冗余。 继承和动态内存分配 假设基类使用了动态内存分配，而派生类中不使用new： 是否需要显式定义析构函数？ 不需要。 派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。 由于不需要额外执行特殊操作，所以不需要显式定义，用默认析构函数就行。 是否需要显式定义复制构造函数？ 不需要。 复制类成员或继承的类组件时，是使用该类的复制构造函数完成的。也就是说基类部分的复制是调用基类的复制构造函数，而派生类部分使用派生类的复制构造函数。 这主要是考虑了动态内存分配。基类的复制构造函数保证了深复制，而派生类没有额外new，所以自动调用默认的复制构造函数，执行浅复制就行。 是否需要显式定义赋值运算符？ 不需要，理由同上。 假设派生类中使用了new，则以上三种都要重新显式定义。 派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。 派生类的复制构造函数只能访问派生类的数据，因此它必须调用基类的复制构造函数来处理共享的基类的数据。 调用派生类的复制构造函数时，会自动调用基类的默认复制构造函数，但如果需要调用的是基类的某个非默认的复制构造函数，则必须手动显式调用。 对于赋值运算符同理。" />
<meta property="og:description" content="CH13 类继承 面向对象编程的主要目的之是提供可重用的代码。 C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。 下面是可以通过继承完成的一些工作： 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。 可以给类添加数据。例如，对于字符串类，可以派生出一个类，一并添加指定字符串显示颜色的数据成员。 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的Passenger类，可以派生出提供更高级别服务的FirstClassPassenger类。 简单的基类及其派生 class RatedPlayer: public TableTennisPlayer { ... } 冒号指出RatedPlayer类的基类是TableTennisplayer类。 public表明TableTennisPlayer是个公有基类，这被称为公有派生。 使用公有派生，基类的公有成员将成为派生类的公有成员：基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。 上述代码完成了哪些工作呢？Ratedplayer对象将具有以下特征： 派生类对象存储了基类的数据成员（派生类继承了基类的实现）： 派生类对象可以使用基类的方法（派生类继承了基类的接口）。 需要在继承特性中添加什么呢？ 派生类需要自己的构造函数。 派生类可以根据需要添加额外的数据成员和成员函数。 构造函数：访问权限的考虑 派生类不能直接访问基类的私有成员，而必须通过基类提供的公有方法进行访问。 创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建。 上面所说的工作由成员初始化列表语法来完成。 显式的： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer(fn,ln,ht) { rating=r; } 隐式的： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht) { rating=r; } //这种省略成员初始化列表实际上等价于： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer() { rating=r; } 这是因为：必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数。 所以，在任何情况下最好提供一个无参数的默认构造函数！ 如果传入参数是类引用： RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer&amp; tp):TableTennisPlayer(tp) { rating=r; } 由王tp的类型为TableTennisPlayer&amp;，因此将调用基类的复制构造函数（这个浅复制是可以接受的，因为没有使用new）。 基类没有定义复制构造函数，如果需要使用复制构造函数但又没有定义，编译器将自动生成一个。 此外，可以把基类也看做派生类的成员之一，因为初始化派生类时要先初始化基类，而这一步的形式和初始化派生类成员是一样的。 RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer &amp; tp):TableTennisPlayer(tp),rating(r) { ... } 使用派生类 要使用派生类，程序必须要能够问基类声明。 可以将这两种类的声明置于同一个头文件中，也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。 派生类和基类之间的关系 派生类与基类之间有一些特殊关系： 派生类对象可以使用基类的非私有方法 基类指针可以在不进行显式类型转换的情况下指向派生类对象（只能单向） 基类引用可以在不进行显式类型转换的情况下引用派生类对象（只能单向） Ratedplayer rplayer1(1140,&quot;Mallory&quot;,&quot;Duck&quot;,true); TableTennisplayer&amp; rt=rplayer; TableTennisplayer* pt=&amp;rplayer; rt.Name();//invoke Name()with reference pt-&gt;Name();//invoke Name()with pointer 然而： 基类指针或引用只能用于调用基类方法。因此，不能使用rt或pt来调用派生类的ResetRanking方法。 不可以将基类对象和地址赋给派生类引用和指针。 对于形参为指向基类的指针的函数，它可以使用基类对象的地址或派生类对象的地址作为实参。 引用兼容性属性也能够将基类对象初始化为派生类对象： RatedPlayer olaf1(1840,&quot;Olaf&quot;,&quot;Loaf&quot;,true); TableTennisPlayer olaf2(olaf1); 理论上，需要这样的构造函数原型来初始化olaf2： TableTennisPlayer(const RatedPlayer &amp;); //doesn&#39;t exist 类定义中没有这样的构造函数，但存在隐式复制构造函数： TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor 由于可以发生从派生类到基类的隐式转换，所以这个复制构造函数能够接受派生类引用作为参数。 对于赋值运算符也是一样的： TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor RatedPlayer olaf1(1840,&quot;Olaf&quot;,&quot;Loaf&quot;,true); TableTennisPlayer winner; winner=olaf; //assign derived to base object 存在隐式重载赋值运算符： TableTennisPlayer &amp; operator=(const TableTennisPlayer &amp;)const; 在上面的部分中，只有派生类的基类部分会赋值给基类。 is-a继承 一般而言，认为普通公有继承只建立is-a，或者说is-a-kind-of关系。 例如，可以从Fruit派生出Banana。 公有继承不能实现以下关系： is-like-a关系，不能采取明喻。人们通常说律师就像鲨鱼，但律师并不是鲨鱼。所以不能从Shark派生出Lawyer类。 is-implemented-as-a，作为…来实现关系。例如，可以使用数组来实现栈，但不能从Array类派生出Stack类。 uses-a关系。计算机可以使用打印机，但是不能从Computer派生出Printer类。 多态公有继承 多态公有继承指的是一个类公有地继承另一个类，并重写基类的虚函数，从而实现多态行为。主要涉及到两个部分：公有继承和多态。 多态（Polymorphism）是面向对象编程的一个重要特性，它允许我们通过基类的指针或引用来操作派生类对象。 在C++中，多态是通过虚函数（virtual functions）来实现的。如果一个基类定义了一个虚函数，那么派生类可以重写（override）这个函数。然后，我们可以通过基类的指针或引用来调用这个函数，而实际执行的是派生类版本的函数。这就是所谓的动态绑定或后期绑定（late binding）。 有两种机制可以用于实现多态公有继承： 在派生类中重新定义基类的方法 使用虚方法 class Brass { private: std::string fullName; long acctNum; double balance; public: Brass(const std::string&amp;s= &quot;Nullbody&quot;,long an =-1, double bal=0.0); void Deposit(double amt); virtual void Withdraw(double amt); double Balance() const; virtual void ViewAcct() const; virtual ~Brass(){} }; class BrassPlus:public Brass { private: double maxLoan; double rate; double owesBank; public: BrassPlus(const std::string &amp; s =&quot;Nullbody&quot;,long an=-1, double bal=0.0,double ml=500, double r=0.11125); BrassPlus(const Brass &amp; ba,double ml= 500, double r=0.11125); virtual void ViewAcct()const; virtual void Withdraw(double amt); void ResetMax(double m){maxLoan=m;} void ResetRate(double r){rate=r;} void ResetOwes(){owesBank=0;} }; Withdraw()函数有2个版本，这说明基类和派生类在这两个函数中的行为不同（对于在两个类中行为相同的方法，则只在基类中声明）。 如果方法是通过引用或指针而不是对象调用的，关键字Virtual将确定使用哪一种方法。 如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法。 Brass dom (&quot;Dominic-Banker&quot;,11224,4183.45) Brassplus dot (&quot;Dorothy Banker&quot;,12118,2592.00); Brass &amp; bl_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct();//use Brass::ViewAcct() b2_ref.ViewAcct();//use Brass::ViewAcct() 如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。 Brass dom (&quot;Dominic-Banker&quot;,11224,4183.45) Brassplus dot (&quot;Dorothy Banker&quot;,12118,2592.00); Brass &amp; bl_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct();//use Brass::ViewAcct() b2_ref.ViewAcct();//use Brassplus::ViewAcct() 方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。 也可以在派生类中使用virtual来强调这一事实。（不然程序员很可能会忘记） 类实现 关键字virtual只用于类声明的方法原型中，而不允许在方法文件中实现中使用！ 代码必须使用作用域解析运算符（特别是当派生类的重载函数中调用了基类的同名函数时），否则发生递归调用。 基类与派生类的数组 假设要同时管理Brass和BrassPlus账户，如果能使用同一个数组来保存Brsss和BrassPlus对象，将很有帮助。 但这是不可能的，因为数组中所有元素的类型必须相同，而Brass和BrassPlus是不同的类型。 然而，可以创建指向Brass的指针数组。由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。 多态真是美妙！ 静态联编和动态联编 程序调用函数时，将使用哪个可执行代码块呢？ 编译器将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。 在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。 生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。 指针、引用类型的兼容 BrassPlus dilly(&quot;Annie Dill&quot;,493222,2000); Brass* pb=&amp;dilly; Brass&amp; pb=dilly; 将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。 向上强制转换是可传递的，也就是说，如果从BrassPlus派生出BrassPlusPlus类，则Brass指针或引用可以引用Brass对象、BrassPlus对象或BrassPlusPlus对象。 相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。 如果不使用显式类型转换，则向下强制转换是不允许的。 通常不推荐这么做，唯一有可能的情况是：本来这个基类指针指向的就是派生类对象，再将其转换成派生类指针。 class Base { public: virtual ~Base() {} }; class Derived : public Base { public: void sayHello() { std::cout &lt;&lt; &quot;Hello from Derived!&quot; &lt;&lt; std::endl; } }; int main() { Base* b = new Derived(); // Upcasting // Downcasting Derived* d = (Derived*)(b); if (d) { // Check if the downcasting was successful d-&gt;sayHello(); // Now it&#39;s safe to call } delete b; return 0; } 两种类型的联编 为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，所以会有额外处理开销。所以使用静态联编效率更高。 如果派生类不重新定义基类的任何方法，就不需要使用动态联编。 虚函数的工作原理 通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。 隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table, vtbl）。（究竟有多少级指针呢？） 虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。 如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址。 如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。 再整理一下概念： 虚函数表（vtable）：当一个类中声明了虚函数，编译器会为这个类生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是指向类的虚函数的指针。每个类的虚函数表是唯一的，所有该类的对象都共享同一个虚函数表。 虚指针（vptr）：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个虚指针指向该类的虚函数表。如果有派生类对象，那么派生类对象的虚指针会指向派生类的虚函数表。 动态绑定：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后在虚函数表中查找并调用相应的虚函数。这个过程是在运行时进行的，因此称为动态绑定。 使用虚函数时，在内存和执行速度方面有一定的成本，包括： 每个对象都将增大，增大量为存储地址的空间。 对于每个类，编译器都创建一个虚函数地址表（数组）。 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。 有关虚函数注意事项 构造函数 构造函数不能是虚函数。实际上，这没有意义 创建派生类对象时，将调用派生类的构造函数，然后派生类的构造函数会调用基类的一个构造函数。 也就是说派生类不继承基类的构造函数。 析构函数 通常应给基类提供一个虚析构函数（这样派生类的析构函数自动也成为虚的），即使它并不需要析构函数。 考虑这样的场景： Employee * pe=new Singer; ... delete pe; 如果析构函数不是虚的，那么delete只会释放基类部分的内存（会引发问题！）。 如果析构函数是虚的，那么先调用派生类的析构，再自动调用基类的析构函数（这是声明周期管理的特性）。 友元 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。 如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。 没有重新定义 如果派生类没有重新定义函数，将使用该函数的基类版本。 如果派生类位于派生链中，则将使用最新的虚函数版本（虚函数不是不能用！）。 也就是说从某个类开始声明了虚函数，那么后面所有的版本无论是否重新定义，都自动成为虚函数。 例外的情况是基类版本是隐藏的（稍后将介绍） 重新定义将隐藏方法 如果派生类中的函数和基类中的虚函数有相同的名称和参数列表，那么派生类中的函数将覆盖（也称为重写）基类中的虚函数，这是虚函数的正常使用方式。 如果派生类中的函数和基类中的函数具有相同的名称，但参数列表不同，那么派生类中的函数将会隐藏基类中所有同名的函数，无论参数列表是否相同。 如果你想在派生类中使用和基类中同名但参数列表不同的函数，而不隐藏基类中的函数，你可以使用using声明。 这引出了两条经验规则： 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。（也即：可以允许返回类型不同的重载） 这种允许返回类型随类类型的变化而变化的特性被称为返回类型协变（covariance of return type）。 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。 访问控制：protected private和protected之间的区别只有在基类派生的类中才会表现出来。 派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。 抽象基类（ABC） C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0，参见： class BaseEllipse { public: virtual double Area() const=0; } 纯虚函数的理念是：包含纯虚函数的类只用作基类。 当类声明中包含纯虚函数时，则不能创建该类的对象。 这里的方法Area()没有定义，但C++甚至允许纯虚函数有定义： //myclass.h void Move(int nx,ny)=0; //myclass.cpp void BaseEllipse::Move(int nx,ny){x=nx;y=ny;} ... 为什么不干脆直接将派生类们分开定义？因为它们还是有共同之处的，所以这种解决办法效率不高，也从逻辑上比较冗余。 继承和动态内存分配 假设基类使用了动态内存分配，而派生类中不使用new： 是否需要显式定义析构函数？ 不需要。 派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。 由于不需要额外执行特殊操作，所以不需要显式定义，用默认析构函数就行。 是否需要显式定义复制构造函数？ 不需要。 复制类成员或继承的类组件时，是使用该类的复制构造函数完成的。也就是说基类部分的复制是调用基类的复制构造函数，而派生类部分使用派生类的复制构造函数。 这主要是考虑了动态内存分配。基类的复制构造函数保证了深复制，而派生类没有额外new，所以自动调用默认的复制构造函数，执行浅复制就行。 是否需要显式定义赋值运算符？ 不需要，理由同上。 假设派生类中使用了new，则以上三种都要重新显式定义。 派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。 派生类的复制构造函数只能访问派生类的数据，因此它必须调用基类的复制构造函数来处理共享的基类的数据。 调用派生类的复制构造函数时，会自动调用基类的默认复制构造函数，但如果需要调用的是基类的某个非默认的复制构造函数，则必须手动显式调用。 对于赋值运算符同理。" />
<link rel="canonical" href="/csnotes/2024/02/11/CH13-%E7%B1%BB%E7%BB%A7%E6%89%BF.html" />
<meta property="og:url" content="/csnotes/2024/02/11/CH13-%E7%B1%BB%E7%BB%A7%E6%89%BF.html" />
<meta property="og:site_name" content="Step far." />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2024-02-11T00:00:00+00:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="CH13 类继承" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"DragonK"},"dateModified":"2024-02-11T00:00:00+00:00","datePublished":"2024-02-11T00:00:00+00:00","description":"CH13 类继承 面向对象编程的主要目的之是提供可重用的代码。 C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。 下面是可以通过继承完成的一些工作： 可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。 可以给类添加数据。例如，对于字符串类，可以派生出一个类，一并添加指定字符串显示颜色的数据成员。 可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的Passenger类，可以派生出提供更高级别服务的FirstClassPassenger类。 简单的基类及其派生 class RatedPlayer: public TableTennisPlayer { ... } 冒号指出RatedPlayer类的基类是TableTennisplayer类。 public表明TableTennisPlayer是个公有基类，这被称为公有派生。 使用公有派生，基类的公有成员将成为派生类的公有成员：基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。 上述代码完成了哪些工作呢？Ratedplayer对象将具有以下特征： 派生类对象存储了基类的数据成员（派生类继承了基类的实现）： 派生类对象可以使用基类的方法（派生类继承了基类的接口）。 需要在继承特性中添加什么呢？ 派生类需要自己的构造函数。 派生类可以根据需要添加额外的数据成员和成员函数。 构造函数：访问权限的考虑 派生类不能直接访问基类的私有成员，而必须通过基类提供的公有方法进行访问。 创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建。 上面所说的工作由成员初始化列表语法来完成。 显式的： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer(fn,ln,ht) { rating=r; } 隐式的： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht) { rating=r; } //这种省略成员初始化列表实际上等价于： RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer() { rating=r; } 这是因为：必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数。 所以，在任何情况下最好提供一个无参数的默认构造函数！ 如果传入参数是类引用： RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer&amp; tp):TableTennisPlayer(tp) { rating=r; } 由王tp的类型为TableTennisPlayer&amp;，因此将调用基类的复制构造函数（这个浅复制是可以接受的，因为没有使用new）。 基类没有定义复制构造函数，如果需要使用复制构造函数但又没有定义，编译器将自动生成一个。 此外，可以把基类也看做派生类的成员之一，因为初始化派生类时要先初始化基类，而这一步的形式和初始化派生类成员是一样的。 RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer &amp; tp):TableTennisPlayer(tp),rating(r) { ... } 使用派生类 要使用派生类，程序必须要能够问基类声明。 可以将这两种类的声明置于同一个头文件中，也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。 派生类和基类之间的关系 派生类与基类之间有一些特殊关系： 派生类对象可以使用基类的非私有方法 基类指针可以在不进行显式类型转换的情况下指向派生类对象（只能单向） 基类引用可以在不进行显式类型转换的情况下引用派生类对象（只能单向） Ratedplayer rplayer1(1140,&quot;Mallory&quot;,&quot;Duck&quot;,true); TableTennisplayer&amp; rt=rplayer; TableTennisplayer* pt=&amp;rplayer; rt.Name();//invoke Name()with reference pt-&gt;Name();//invoke Name()with pointer 然而： 基类指针或引用只能用于调用基类方法。因此，不能使用rt或pt来调用派生类的ResetRanking方法。 不可以将基类对象和地址赋给派生类引用和指针。 对于形参为指向基类的指针的函数，它可以使用基类对象的地址或派生类对象的地址作为实参。 引用兼容性属性也能够将基类对象初始化为派生类对象： RatedPlayer olaf1(1840,&quot;Olaf&quot;,&quot;Loaf&quot;,true); TableTennisPlayer olaf2(olaf1); 理论上，需要这样的构造函数原型来初始化olaf2： TableTennisPlayer(const RatedPlayer &amp;); //doesn&#39;t exist 类定义中没有这样的构造函数，但存在隐式复制构造函数： TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor 由于可以发生从派生类到基类的隐式转换，所以这个复制构造函数能够接受派生类引用作为参数。 对于赋值运算符也是一样的： TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor RatedPlayer olaf1(1840,&quot;Olaf&quot;,&quot;Loaf&quot;,true); TableTennisPlayer winner; winner=olaf; //assign derived to base object 存在隐式重载赋值运算符： TableTennisPlayer &amp; operator=(const TableTennisPlayer &amp;)const; 在上面的部分中，只有派生类的基类部分会赋值给基类。 is-a继承 一般而言，认为普通公有继承只建立is-a，或者说is-a-kind-of关系。 例如，可以从Fruit派生出Banana。 公有继承不能实现以下关系： is-like-a关系，不能采取明喻。人们通常说律师就像鲨鱼，但律师并不是鲨鱼。所以不能从Shark派生出Lawyer类。 is-implemented-as-a，作为…来实现关系。例如，可以使用数组来实现栈，但不能从Array类派生出Stack类。 uses-a关系。计算机可以使用打印机，但是不能从Computer派生出Printer类。 多态公有继承 多态公有继承指的是一个类公有地继承另一个类，并重写基类的虚函数，从而实现多态行为。主要涉及到两个部分：公有继承和多态。 多态（Polymorphism）是面向对象编程的一个重要特性，它允许我们通过基类的指针或引用来操作派生类对象。 在C++中，多态是通过虚函数（virtual functions）来实现的。如果一个基类定义了一个虚函数，那么派生类可以重写（override）这个函数。然后，我们可以通过基类的指针或引用来调用这个函数，而实际执行的是派生类版本的函数。这就是所谓的动态绑定或后期绑定（late binding）。 有两种机制可以用于实现多态公有继承： 在派生类中重新定义基类的方法 使用虚方法 class Brass { private: std::string fullName; long acctNum; double balance; public: Brass(const std::string&amp;s= &quot;Nullbody&quot;,long an =-1, double bal=0.0); void Deposit(double amt); virtual void Withdraw(double amt); double Balance() const; virtual void ViewAcct() const; virtual ~Brass(){} }; class BrassPlus:public Brass { private: double maxLoan; double rate; double owesBank; public: BrassPlus(const std::string &amp; s =&quot;Nullbody&quot;,long an=-1, double bal=0.0,double ml=500, double r=0.11125); BrassPlus(const Brass &amp; ba,double ml= 500, double r=0.11125); virtual void ViewAcct()const; virtual void Withdraw(double amt); void ResetMax(double m){maxLoan=m;} void ResetRate(double r){rate=r;} void ResetOwes(){owesBank=0;} }; Withdraw()函数有2个版本，这说明基类和派生类在这两个函数中的行为不同（对于在两个类中行为相同的方法，则只在基类中声明）。 如果方法是通过引用或指针而不是对象调用的，关键字Virtual将确定使用哪一种方法。 如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法。 Brass dom (&quot;Dominic-Banker&quot;,11224,4183.45) Brassplus dot (&quot;Dorothy Banker&quot;,12118,2592.00); Brass &amp; bl_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct();//use Brass::ViewAcct() b2_ref.ViewAcct();//use Brass::ViewAcct() 如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法。 Brass dom (&quot;Dominic-Banker&quot;,11224,4183.45) Brassplus dot (&quot;Dorothy Banker&quot;,12118,2592.00); Brass &amp; bl_ref = dom; Brass &amp; b2_ref = dot; b1_ref.ViewAcct();//use Brass::ViewAcct() b2_ref.ViewAcct();//use Brassplus::ViewAcct() 方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。 也可以在派生类中使用virtual来强调这一事实。（不然程序员很可能会忘记） 类实现 关键字virtual只用于类声明的方法原型中，而不允许在方法文件中实现中使用！ 代码必须使用作用域解析运算符（特别是当派生类的重载函数中调用了基类的同名函数时），否则发生递归调用。 基类与派生类的数组 假设要同时管理Brass和BrassPlus账户，如果能使用同一个数组来保存Brsss和BrassPlus对象，将很有帮助。 但这是不可能的，因为数组中所有元素的类型必须相同，而Brass和BrassPlus是不同的类型。 然而，可以创建指向Brass的指针数组。由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。 多态真是美妙！ 静态联编和动态联编 程序调用函数时，将使用哪个可执行代码块呢？ 编译器将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。 在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。 生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。 指针、引用类型的兼容 BrassPlus dilly(&quot;Annie Dill&quot;,493222,2000); Brass* pb=&amp;dilly; Brass&amp; pb=dilly; 将派生类引用或指针转换为基类引用或指针被称为向上强制转换（upcasting），这使公有继承不需要进行显式类型转换。 向上强制转换是可传递的，也就是说，如果从BrassPlus派生出BrassPlusPlus类，则Brass指针或引用可以引用Brass对象、BrassPlus对象或BrassPlusPlus对象。 相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。 如果不使用显式类型转换，则向下强制转换是不允许的。 通常不推荐这么做，唯一有可能的情况是：本来这个基类指针指向的就是派生类对象，再将其转换成派生类指针。 class Base { public: virtual ~Base() {} }; class Derived : public Base { public: void sayHello() { std::cout &lt;&lt; &quot;Hello from Derived!&quot; &lt;&lt; std::endl; } }; int main() { Base* b = new Derived(); // Upcasting // Downcasting Derived* d = (Derived*)(b); if (d) { // Check if the downcasting was successful d-&gt;sayHello(); // Now it&#39;s safe to call } delete b; return 0; } 两种类型的联编 为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，所以会有额外处理开销。所以使用静态联编效率更高。 如果派生类不重新定义基类的任何方法，就不需要使用动态联编。 虚函数的工作原理 通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。 隐藏成员中保存了一个指向函数地址数组的指针。这种数组称为虚函数表（virtual function table, vtbl）。（究竟有多少级指针呢？） 虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。 如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址。 如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。 再整理一下概念： 虚函数表（vtable）：当一个类中声明了虚函数，编译器会为这个类生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是指向类的虚函数的指针。每个类的虚函数表是唯一的，所有该类的对象都共享同一个虚函数表。 虚指针（vptr）：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个虚指针指向该类的虚函数表。如果有派生类对象，那么派生类对象的虚指针会指向派生类的虚函数表。 动态绑定：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后在虚函数表中查找并调用相应的虚函数。这个过程是在运行时进行的，因此称为动态绑定。 使用虚函数时，在内存和执行速度方面有一定的成本，包括： 每个对象都将增大，增大量为存储地址的空间。 对于每个类，编译器都创建一个虚函数地址表（数组）。 对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。 有关虚函数注意事项 构造函数 构造函数不能是虚函数。实际上，这没有意义 创建派生类对象时，将调用派生类的构造函数，然后派生类的构造函数会调用基类的一个构造函数。 也就是说派生类不继承基类的构造函数。 析构函数 通常应给基类提供一个虚析构函数（这样派生类的析构函数自动也成为虚的），即使它并不需要析构函数。 考虑这样的场景： Employee * pe=new Singer; ... delete pe; 如果析构函数不是虚的，那么delete只会释放基类部分的内存（会引发问题！）。 如果析构函数是虚的，那么先调用派生类的析构，再自动调用基类的析构函数（这是声明周期管理的特性）。 友元 友元不能是虚函数，因为友元不是类成员，而只有成员才能是虚函数。 如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。 没有重新定义 如果派生类没有重新定义函数，将使用该函数的基类版本。 如果派生类位于派生链中，则将使用最新的虚函数版本（虚函数不是不能用！）。 也就是说从某个类开始声明了虚函数，那么后面所有的版本无论是否重新定义，都自动成为虚函数。 例外的情况是基类版本是隐藏的（稍后将介绍） 重新定义将隐藏方法 如果派生类中的函数和基类中的虚函数有相同的名称和参数列表，那么派生类中的函数将覆盖（也称为重写）基类中的虚函数，这是虚函数的正常使用方式。 如果派生类中的函数和基类中的函数具有相同的名称，但参数列表不同，那么派生类中的函数将会隐藏基类中所有同名的函数，无论参数列表是否相同。 如果你想在派生类中使用和基类中同名但参数列表不同的函数，而不隐藏基类中的函数，你可以使用using声明。 这引出了两条经验规则： 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。（也即：可以允许返回类型不同的重载） 这种允许返回类型随类类型的变化而变化的特性被称为返回类型协变（covariance of return type）。 如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。 访问控制：protected private和protected之间的区别只有在基类派生的类中才会表现出来。 派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。 最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。 抽象基类（ABC） C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0，参见： class BaseEllipse { public: virtual double Area() const=0; } 纯虚函数的理念是：包含纯虚函数的类只用作基类。 当类声明中包含纯虚函数时，则不能创建该类的对象。 这里的方法Area()没有定义，但C++甚至允许纯虚函数有定义： //myclass.h void Move(int nx,ny)=0; //myclass.cpp void BaseEllipse::Move(int nx,ny){x=nx;y=ny;} ... 为什么不干脆直接将派生类们分开定义？因为它们还是有共同之处的，所以这种解决办法效率不高，也从逻辑上比较冗余。 继承和动态内存分配 假设基类使用了动态内存分配，而派生类中不使用new： 是否需要显式定义析构函数？ 不需要。 派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。 由于不需要额外执行特殊操作，所以不需要显式定义，用默认析构函数就行。 是否需要显式定义复制构造函数？ 不需要。 复制类成员或继承的类组件时，是使用该类的复制构造函数完成的。也就是说基类部分的复制是调用基类的复制构造函数，而派生类部分使用派生类的复制构造函数。 这主要是考虑了动态内存分配。基类的复制构造函数保证了深复制，而派生类没有额外new，所以自动调用默认的复制构造函数，执行浅复制就行。 是否需要显式定义赋值运算符？ 不需要，理由同上。 假设派生类中使用了new，则以上三种都要重新显式定义。 派生类析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。 派生类的复制构造函数只能访问派生类的数据，因此它必须调用基类的复制构造函数来处理共享的基类的数据。 调用派生类的复制构造函数时，会自动调用基类的默认复制构造函数，但如果需要调用的是基类的某个非默认的复制构造函数，则必须手动显式调用。 对于赋值运算符同理。","headline":"CH13 类继承","mainEntityOfPage":{"@type":"WebPage","@id":"/csnotes/2024/02/11/CH13-%E7%B1%BB%E7%BB%A7%E6%89%BF.html"},"url":"/csnotes/2024/02/11/CH13-%E7%B1%BB%E7%BB%A7%E6%89%BF.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="icon" href="">
  <link rel="canonical" href="">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-noto-sans@0.0.72/index.min.css">
  <link rel="stylesheet" href="/assets/css/main.css">
  <script src="/assets/js/main.js"></script><link type="application/atom+xml" rel="alternate" href="/feed.xml" title="Step far." /><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
<!-- and it's easy to individually load additional languages -->
<script charset="UTF-8"
        src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/languages/go.min.js"
        async></script>



















<script>
// Init highlight js
document.addEventListener('DOMContentLoaded', function(event) {
  var els = document.querySelectorAll('pre code')

  function addLangData(block) {
    var outer = block.parentElement.parentElement.parentElement;
    var lang = block.getAttribute('data-lang');
    for (var i = 0; i < outer.classList.length; i++) {
      var cls = outer.classList[i];
      if (cls.startsWith('language-')) {
        lang = cls;
        break;
      }
    }
    if (!lang) {
      cls = block.getAttribute('class');
      lang = cls ? cls.replace('hljs ', '') : '';
    }
    if (lang.startsWith('language-')) {
      lang = lang.substr(9);
    }
    block.setAttribute('class', 'hljs ' + lang);
    block.parentNode.setAttribute('data-lang', lang);
  }

  function addBadge(block) {
    var enabled = ('true' || 'true').toLowerCase();
    if (enabled == 'true') {
      var pre = block.parentElement;
      pre.classList.add('badge');
    }
  }

  function handle(block) {
    addLangData(block);
    addBadge(block)
    hljs.highlightBlock(block);
  }

  for (var i = 0; i < els.length; i++) {
    var el = els[i];
    handle(el);
  }
});
</script>

<style>
  /* code language badge */
  pre.badge::before {
    content: attr(data-lang);
    color: #fff;
    background-color: #ff4e00;
    padding: 0 .5em;
    border-radius: 0 2px;
    text-transform: uppercase;
    text-align: center;
    min-width: 32px;
    display: inline-block;
    position: absolute;
    right: 0;
  }

  /* fix wrong badge display for firefox browser */
  code > table pre::before {
    display: none;
  }
</style>
<script
  src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe-lightbox.umd.min.js" async></script>
<script
  src="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/umd/photoswipe.umd.min.js" async></script>
<link
  href="//cdnjs.cloudflare.com/ajax/libs/photoswipe/5.3.7/photoswipe.min.css"
  rel="stylesheet"
/>
<style>
  .pswp .pswp__container .pswp__img {
    background-color: white;
  }
</style>

<script>
  function initPhotoSwipe() {
    let customOptions = {};

    try {
      const data = ``.replaceAll("=>", ":");
      customOptions = JSON.parse(data);
    } catch (e) {
      console.info("Invalid custom photo previewer options! " + e.message);
    }

    // Define object and gallery options
    const options = Object.assign(
      {
        gallery: "section.main",
        children: "a.photo-swipe",
        photo_scale: 2,
        // dynamic import is not supported in UMD version
        pswpModule: PhotoSwipe,
      },
      customOptions
    );

    const galleryEl = document.querySelector(options.gallery);
    if (!galleryEl) {
      return;
    }

    const imgEls = [];
    const els = galleryEl.querySelectorAll("img:not(.emoji)");
    els.forEach((el) => {
      if (el.src.trim() == "") {
        return;
      }
      if (!imgEls.includes(el)) {
        imgEls.push(el);
      }
    });

    if (imgEls.length === 0) {
      return;
    }

    imgEls.forEach((imgEl) => {
      imgEl.outerHTML = `
      <a class="photo-swipe"
        href="${imgEl.src}"
        data-pswp-width="${
          Math.max(imgEl.naturalWidth, imgEl.width) * options.photo_scale
        }"
        data-pswp-height="${
          Math.max(imgEl.naturalHeight, imgEl.height) * options.photo_scale
        }"
        data-pswp-caption="${imgEl.getAttribute("caption") || imgEl.alt}"
        target="_blank">
        ${imgEl.outerHTML}
      </a>`;
    });

    // Initialize PhotoSwipe 5
    var lightbox = new PhotoSwipeLightbox(options);

    lightbox.init();
  }

  window.addEventListener("load", initPhotoSwipe);
</script>
</head>
<body>



























































































































<header class="site-header " role="banner">

  <div class="wrapper">
    <div class="site-header-inner"><span class="site-brand"><a class="site-brand-inner" rel="author" href="/">
  <img class="site-favicon" title="Step far." src="" onerror="this.style.display='none'">
  Step far.
</a>
</span><nav class="site-nav">
          <input type="checkbox" id="nav-trigger" class="nav-trigger" />
          <label for="nav-trigger">
            <span class="menu-icon">
              <svg viewBox="0 0 18 15" width="18px" height="15px">
                <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
              </svg>
            </span>
          </label>

          <div class="trigger"><a class="page-link" href="/about.html">ABOUT</a><a class="page-link" href="/archives.html">ARCHIVES</a><a class="page-link" href="/categories.html">CATEGORIES</a><a class="page-link" href="/">HOME</a><a class="page-link" href="/tags.html">TAGS</a>









<span class="page-link">



<div id="google_translate_element" style="display: none;">
</div>

<span class="ct-language">
  <ul class="list-unstyled ct-language-dropdown">
    
      <li>
        <a href="#" class="lang-select" data-lang="en">
          
          <img src="https://cdn.countryflags.com/thumbs/united-states-of-america/flag-400.png" title="English">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="fr">
          
          <img src="https://cdn.countryflags.com/thumbs/france/flag-400.png" title="French">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="zh-CN">
          
          <img src="https://cdn.countryflags.com/thumbs/china/flag-400.png" title="Chinese(Simple)">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ja">
          
          <img src="https://cdn.countryflags.com/thumbs/japan/flag-400.png" title="Japanese">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ko">
          
          <img src="https://cdn.countryflags.com/thumbs/south-korea/flag-400.png" title="Korean">
          
        </a>
      </li>
    
      <li>
        <a href="#" class="lang-select" data-lang="ru">
          
          <img src="https://cdn.countryflags.com/thumbs/russia/flag-400.png" title="Russian">
          
        </a>
      </li>
    
  </ul>
</span>

<script type="text/javascript">
function googleTranslateElementInit() {
  new google.translate.TranslateElement({
    pageLanguage: 'en',
    autoDisplay: false,
    layout: google.translate.TranslateElement.InlineLayout.VERTICAL
  }, 'google_translate_element');

  // Links to cross-origin destinations are unsafe
  var gll = document.getElementsByClassName('goog-logo-link')[0];
  if (gll) {
    gll.setAttribute('rel', 'noopener');
  }

  function restoreLang() {
    var iframe = document.getElementsByClassName('goog-te-banner-frame')[0];
    if (!iframe) return;

    var innerDoc = iframe.contentDocument || iframe.contentWindow.document;
    var restore_el = innerDoc.getElementsByTagName("button");

    for (var i = 0; i < restore_el.length; i++) {
      if (restore_el[i].id.indexOf("restore") >= 0) {
        restore_el[i].click();
        var close_el = innerDoc.getElementsByClassName("goog-close-link");
        close_el[0].click();
        return;
      }
    }
  }

  function triggerHtmlEvent(element, eventName) {
    var event;
    if (document.createEvent) {
      event = document.createEvent('HTMLEvents');
      event.initEvent(eventName, true, true);
      element.dispatchEvent(event);
    } else {
      event = document.createEventObject();
      event.eventType = eventName;
      element.fireEvent('on' + event.eventType, event);
    }
  }

  var googleCombo = document.querySelector("select.goog-te-combo");
  var langSelect = document.querySelector('.ct-language');
  langSelect.addEventListener('click', function(event) {
    if (!event.target) {
      return;
    }

    var selected = document.querySelector('.ct-language .ct-language-selected');
    if (selected) {
      selected.classList.remove('ct-language-selected');
    }

    var target = event.target;
    while (target && target !== langSelect ) {
      if (target.matches('.lang-select')) {
        break;
      }
      target = target.parentElement;
    }

    if (target && target.matches('.lang-select')) {
      var lang = target.getAttribute('data-lang');
      if (googleCombo.value == lang) {
        restoreLang();
      } else {
        target.parentElement.classList.add('ct-language-selected');
        googleCombo.value = lang;
        triggerHtmlEvent(googleCombo, 'change');
      }
    }

    event.preventDefault();
  });
}
</script>

<script type="text/javascript" src="https://translate.google.com/translate_a/element.js?cb=googleTranslateElementInit" async></script>
</span></div>
        </nav></div>
  </div>
</header>

<script>
  function initHeader() {
    var lastScrollY = getScrollPos().y;
    var documentElement = document.documentElement;

    function storeScrollData() {
      var y = getScrollPos().y;var scrollStatus = "";

      if (y <= 0) {
        scrollStatus = "top";
      } else if ((window.innerHeight + y) >= document.body.offsetHeight) {
        scrollStatus = "bottom";
      } else {
        var isScrollDown = (y - lastScrollY > 0) ? true : false;
        scrollStatus = isScrollDown ? "down" : "up";
      }

      lastScrollY = y;
      documentElement.setAttribute("data-scroll-status", scrollStatus);
    }

    window.addEventListener('scroll', function(e) {
      storeScrollData();
    });

    storeScrollData();
  }
  document.addEventListener('DOMContentLoaded', initHeader);
</script>
















































































































































<script>
  function hashLocate(hashValue) {
    hashValue = hashValue.replace(/^.*#h-/, '');
    hashValue = decodeURIComponent(hashValue);
    var element = document.getElementById(hashValue);

    if (!element) {
      return;
    }

    var header = document.querySelector('header.site-header');
    var headerRect = header.getBoundingClientRect();
    var headerTop = Math.floor(headerRect.top);
    var headerHeight = Math.floor(headerRect.height);
    var scrollPos = getScrollPos();
    var offsetY = element.offsetTop - (headerTop + headerHeight + 20);

    if (offsetY == scrollPos.y) {
      return;
    }

    if (headerTop == 0  && offsetY > scrollPos.y) {
      offsetY += headerHeight + 2;
    } else if (headerTop < 0  && offsetY < scrollPos.y) {
      offsetY -= headerHeight - 2;
    }

    smoothScrollTo(offsetY);
  }

  // The first event occurred
  window.addEventListener('load', function(event) {
    if (window.location.hash) {
      hashLocate(window.location.hash);
    }
  });

  // The first event occurred
  window.addEventListener('click', function(event) {
    if (event.target.tagName.toLowerCase() == 'a') {
      hashLocate(event.target.getAttribute('href'));
    }
  });
</script>
<div class="theme-toggle">
  <input type="checkbox" id="theme-switch">
  <label for="theme-switch">
    <div class="toggle"></div>
    <div class="names">
      <p class="light">Light</p>
      <p class="dark">Dark</p>
    </div>
  </label>
</div>




<script>
  (function() {
    var sw = document.getElementById('theme-switch');
    var html = document.getElementsByTagName('html')[0];
    var nightModeOption = ('auto' || 'auto').toLowerCase();
    var storage = nightModeOption === 'manual'
        ? localStorage
        : sessionStorage;
    var themeData = loadThemeData();

    function saveThemeData(data) {
      storage.setItem('theme', JSON.stringify(data));
    }

    function loadThemeData() {
      var data = storage.getItem('theme');
      try {
        data = JSON.parse(data ? data : '');
      } catch(e) {
        data = { nightShift: undefined, autoToggleAt: 0 };
        saveThemeData(data);
      }
      return data;
    }

    function handleThemeToggle(nightShift) {
      themeData.nightShift = nightShift;
      saveThemeData(themeData);
      html.dataset.theme = nightShift ? 'dark' : 'light';
      setTimeout(function() {
        sw.checked = nightShift ? true : false;
      }, 50);
    }

    function autoThemeToggle() {
      // Next time point of theme toggle
      var now = new Date();
      var toggleAt = new Date();
      var hours = now.getHours();
      var nightShift = hours >= 19 || hours <=7;

      if (nightShift) {
        if (hours > 7) {
          toggleAt.setDate(toggleAt.getDate() + 1);
        }
        toggleAt.setHours(7);
      } else {
        toggleAt.setHours(19);
      }

      toggleAt.setMinutes(0);
      toggleAt.setSeconds(0);
      toggleAt.setMilliseconds(0)

      var delay = toggleAt.getTime() - now.getTime();

      // auto toggle theme mode
      setTimeout(function() {
        handleThemeToggle(!nightShift);
      }, delay);

      return {
        nightShift: nightShift,
        toggleAt: toggleAt.getTime()
      };
    }

    // Listen the theme toggle event
    sw.addEventListener('change', function(event) {
      handleThemeToggle(event.target.checked);
    });

    if (nightModeOption == 'auto') {
      var data = autoThemeToggle();

      // Toggle theme by local setting
      if (data.toggleAt > themeData.autoToggleAt) {
        themeData.autoToggleAt = data.toggleAt;
        handleThemeToggle(data.nightShift);
      } else {
        handleThemeToggle(themeData.nightShift);
      }
    } else if (nightModeOption == 'manual') {
      handleThemeToggle(themeData.nightShift);
    } else {
      var nightShift = themeData.nightShift;
      if (nightShift === undefined) {
        nightShift = nightModeOption === 'on';
      }
      handleThemeToggle(nightShift);
    }
  })();
</script>
<div id="click-to-top" class="click-to-top">
  <i class="fa fa-arrow-up"></i>
</div>
<script>
  (function () {
    const clickToTop = document.getElementById('click-to-top');
    window.addEventListener('scroll', () => {
      if (window.scrollY > 100) {
        clickToTop.classList.add('show')
      }else {
        clickToTop.classList.remove('show')
      }
    });
    clickToTop.addEventListener('click', () => {
      window.smoothScrollTo(0);
    });
  })();
</script>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <div class="framework">
  <section class="main">

     <div class="post">
  <section>









<header class="post-header">
  <h1 class="post-title p-name" itemprop="name headline">CH13 类继承</h1>
  <h2 class="post-subtitle"></h2>

  <div class="post-meta">
    <time class="dt-published" datetime="2024-02-11T00:00:00+00:00" itemprop="datePublished"><i class="fa fa-calendar"></i> Feb 11, 2024
    </time>
    
































    <span class="post-reading-time left-vsplit"><i class="fa fa-clock-o"></i> About 3 mins</span>
  </div><div class="post-tags"><a class="post-tag" href="/tags.html#C++笔记">#C++笔记</a></div></header>
<article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

    <div class="post-content e-content" itemprop="articleBody">

      <h2 id="ch13-类继承">CH13 类继承</h2>

<p>面向对象编程的主要目的之是提供可重用的代码。</p>

<p>C++提供了比修改代码更好的方法来扩展和修改类。这种方法叫作类继承，它能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。</p>

<p>下面是可以通过继承完成的一些工作：</p>

<ul>
  <li>可以在已有类的基础上添加功能。例如，对于数组类，可以添加数学运算。</li>
  <li>可以给类添加数据。例如，对于字符串类，可以派生出一个类，一并添加指定字符串显示颜色的数据成员。</li>
  <li>可以修改类方法的行为。例如，对于代表提供给飞机乘客的服务的Passenger类，可以派生出提供更高级别服务的FirstClassPassenger类。</li>
</ul>

<h3 id="简单的基类及其派生">简单的基类及其派生</h3>

<pre><code class="language-C++">class RatedPlayer: public TableTennisPlayer
{
    ...
}
</code></pre>

<ul>
  <li>冒号指出RatedPlayer类的基类是TableTennisplayer类。</li>
  <li>public表明TableTennisPlayer是个<strong>公有基类</strong>，这被称为公有派生。</li>
  <li>使用公有派生，基类的公有成员将成为派生类的公有成员：基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问（稍后将介绍保护成员）。</li>
</ul>

<p>上述代码完成了哪些工作呢？Ratedplayer对象将具有以下特征：</p>

<ul>
  <li>派生类对象存储了基类的数据成员（派生类继承了基类的实现）：</li>
  <li>派生类对象可以使用基类的方法（派生类继承了基类的接口）。</li>
</ul>

<p>需要在继承特性中添加什么呢？</p>

<ul>
  <li>派生类需要自己的构造函数。</li>
  <li>派生类可以根据需要添加额外的数据成员和成员函数。</li>
</ul>

<h4 id="构造函数访问权限的考虑">构造函数：访问权限的考虑</h4>

<p>派生类不能直接访问基类的私有成员，而必须通过基类提供的公有方法进行访问。</p>

<p>创建派生类对象时，程序首先创建基类对象。这意味着基类对象应当在程序进入派生类构造函数之前被创建。</p>

<p>上面所说的工作由<strong>成员初始化列表语法</strong>来完成。</p>

<p>显式的：</p>

<pre><code class="language-C++">RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer(fn,ln,ht)
{
    rating=r;
}
</code></pre>

<p>隐式的：</p>

<pre><code class="language-C++">RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht)
{
    rating=r;
}
//这种省略成员初始化列表实际上等价于：
RatedPlayer::RatedPlayer(unsigned int r,const string&amp; fn,const string&amp; ln,bool ht):TableTennisPlayer()
{
    rating=r;
}
</code></pre>

<p>这是因为：必须首先创建基类对象，如果不调用基类构造函数，程序将使用默认的基类构造函数。</p>

<p><strong>所以，在任何情况下最好提供一个无参数的默认构造函数！</strong></p>

<p>如果传入参数是类引用：</p>

<pre><code class="language-C++">RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer&amp; tp):TableTennisPlayer(tp)
{
    rating=r;
}
</code></pre>

<p>由王tp的类型为<code class="language-plaintext highlighter-rouge">TableTennisPlayer&amp;</code>，因此将调用基类的<strong>复制构造函数</strong>（这个浅复制是可以接受的，因为没有使用new）。</p>

<p>基类没有定义复制构造函数，如果需要使用复制构造函数但又没有定义，编译器将自动生成一个。</p>

<hr />

<p>此外，可以把基类也看做派生类的成员之一，因为初始化派生类时要先初始化基类，而这一步的形式和初始化派生类成员是一样的。</p>

<pre><code class="language-C++">RatedPlayer::RatedPlayer(unsigned int r,const TableTennisPlayer &amp; tp):TableTennisPlayer(tp),rating(r)
{
    ...
}
</code></pre>

<h4 id="使用派生类">使用派生类</h4>

<p>要使用派生类，程序必须要能够问基类声明。</p>

<p>可以将这两种类的声明置于同一个头文件中，也可以将每个类放在独立的头文件中，但由于这两个类是相关的，所以把其类声明放在一起更合适。</p>

<h4 id="派生类和基类之间的关系">派生类和基类之间的关系</h4>

<p>派生类与基类之间有一些特殊关系：</p>

<ul>
  <li>派生类对象可以使用基类的<strong>非私有方法</strong></li>
  <li>基类指针可以在不进行<strong>显式</strong>类型转换的情况下指向派生类对象（只能单向）</li>
  <li>基类引用可以在不进行<strong>显式</strong>类型转换的情况下引用派生类对象（只能单向）</li>
</ul>

<pre><code class="language-C++">Ratedplayer rplayer1(1140,"Mallory","Duck",true);
TableTennisplayer&amp; rt=rplayer;
TableTennisplayer* pt=&amp;rplayer;
rt.Name();//invoke Name()with reference
pt-&gt;Name();//invoke Name()with pointer
</code></pre>

<p>然而：</p>

<ul>
  <li>
    <p><strong>基类指针或引用只能用于调用基类方法。</strong>因此，不能使用rt或pt来调用派生类的ResetRanking方法。</p>
  </li>
  <li>
    <p><strong>不可以将基类对象和地址赋给派生类引用和指针。</strong></p>
  </li>
  <li>
    <p>对于形参为指向基类的指针的函数，它可以使用基类对象的地址<strong>或派生类对象</strong>的地址作为实参。</p>
  </li>
  <li>
    <p>引用兼容性属性也能够将基类对象初始化为派生类对象：</p>

    <pre><code class="language-C++">RatedPlayer olaf1(1840,"Olaf","Loaf",true);
TableTennisPlayer olaf2(olaf1);
</code></pre>

    <p>理论上，需要这样的构造函数原型来初始化olaf2：</p>

    <pre><code class="language-C++">TableTennisPlayer(const RatedPlayer &amp;); //doesn't exist
</code></pre>

    <p>类定义中没有这样的构造函数，但存在隐式复制构造函数：</p>

    <pre><code class="language-C++">TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor
</code></pre>

    <p>由于可以发生从派生类到基类的隐式转换，所以这个复制构造函数能够接受派生类引用作为参数。</p>

    <p>对于赋值运算符也是一样的：</p>

    <pre><code class="language-C++">TableTennisPlayer(const TableTennisPlayer &amp;); //implicit copy constructor
RatedPlayer olaf1(1840,"Olaf","Loaf",true);
TableTennisPlayer winner;
winner=olaf; //assign derived to base object
</code></pre>

    <p>存在隐式重载赋值运算符：</p>

    <pre><code class="language-C++">TableTennisPlayer &amp; operator=(const TableTennisPlayer &amp;)const;
</code></pre>

    <p>在上面的部分中，只有派生类的基类部分会赋值给基类。</p>
  </li>
</ul>

<h3 id="is-a继承">is-a继承</h3>

<p>一般而言，认为普通公有继承只建立is-a，或者说is-a-kind-of关系。</p>

<p>例如，可以从Fruit派生出Banana。</p>

<p>公有继承不能实现以下关系：</p>

<ul>
  <li>is-like-a关系，不能采取明喻。人们通常说律师就像鲨鱼，但律师并不是鲨鱼。所以不能从Shark派生出Lawyer类。</li>
  <li>is-implemented-as-a，作为…来实现关系。例如，可以使用数组来实现栈，但不能从Array类派生出Stack类。</li>
  <li>uses-a关系。计算机可以使用打印机，但是不能从Computer派生出Printer类。</li>
</ul>

<h3 id="多态公有继承">多态公有继承</h3>

<p><strong>多态公有继承</strong>指的是一个类公有地继承另一个类，并重写基类的虚函数，从而实现多态行为。主要涉及到两个部分：公有继承和多态。</p>

<p><strong>多态（Polymorphism）</strong>是面向对象编程的一个重要特性，它允许我们通过基类的指针或引用来操作派生类对象。</p>

<p>在C++中，多态是通过<strong>虚函数</strong>（virtual functions）来实现的。<strong>如果一个基类定义了一个虚函数，那么派生类可以重写（override）这个函数。然后，我们可以通过基类的指针或引用来调用这个函数，而实际执行的是派生类版本的函数。</strong>这就是所谓的<strong>动态绑定</strong>或后期绑定（late binding）。</p>

<p>有两种机制可以用于实现多态公有继承：</p>

<ul>
  <li>在派生类中重新定义基类的方法</li>
  <li>使用虚方法</li>
</ul>

<pre><code class="language-C++">class Brass
{
private:
    std::string fullName;
    long acctNum;
    double balance;
public:
    Brass(const std::string&amp;s= "Nullbody",long an =-1,
    double bal=0.0);
    void Deposit(double amt);
    virtual void Withdraw(double amt);
    double Balance() const;
    virtual void ViewAcct() const;
    virtual ~Brass(){}
};

class BrassPlus:public Brass
{
private:
    double maxLoan;
    double rate;
    double owesBank;
public:
    BrassPlus(const std::string &amp; s ="Nullbody",long an=-1,
             double bal=0.0,double ml=500,
             double r=0.11125);
    BrassPlus(const Brass &amp; ba,double ml= 500,
             double r=0.11125);
    virtual void ViewAcct()const;
    virtual void Withdraw(double amt);
    void ResetMax(double m){maxLoan=m;}
    void ResetRate(double r){rate=r;}
    void ResetOwes(){owesBank=0;}
};
</code></pre>

<ul>
  <li>
    <p>Withdraw()函数有2个版本，这说明基类和派生类在这两个函数中的行为不同（对于在两个类中行为相同的方法，则只在基类中声明）。</p>
  </li>
  <li>
    <p>如果方法是通过引用或指针而不是对象调用的，关键字Virtual将确定使用哪一种方法。</p>

    <ul>
      <li>
        <p>如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法。</p>

        <pre><code class="language-C++">Brass dom ("Dominic-Banker",11224,4183.45)
Brassplus dot ("Dorothy Banker",12118,2592.00);
Brass &amp; bl_ref = dom;
Brass &amp; b2_ref = dot;
b1_ref.ViewAcct();//use Brass::ViewAcct()
b2_ref.ViewAcct();//use Brass::ViewAcct()
</code></pre>
      </li>
      <li>
        <p>如果使用了virtual，程序将根据引用或指针<strong>指向的对象的类型</strong>来选择方法。</p>

        <pre><code class="language-C++">Brass dom ("Dominic-Banker",11224,4183.45)
Brassplus dot ("Dorothy Banker",12118,2592.00);
Brass &amp; bl_ref = dom;
Brass &amp; b2_ref = dot;
b1_ref.ViewAcct();//use Brass::ViewAcct()
b2_ref.ViewAcct();//use Brassplus::ViewAcct()
</code></pre>
      </li>
    </ul>
  </li>
  <li>
    <p>方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法。</p>

    <ul>
      <li>也可以在派生类中使用virtual来强调这一事实。（不然程序员很可能会忘记）</li>
    </ul>
  </li>
</ul>

<h4 id="类实现">类实现</h4>

<p><strong>关键字virtual只用于类声明的方法原型中，而不允许在方法文件中实现中使用！</strong></p>

<p><strong>代码必须使用作用域解析运算符（特别是当派生类的重载函数中调用了基类的同名函数时），否则发生递归调用。</strong></p>

<h4 id="基类与派生类的数组">基类与派生类的数组</h4>

<p>假设要同时管理Brass和BrassPlus账户，如果能使用同一个数组来保存Brsss和BrassPlus对象，将很有帮助。</p>

<p>但这是不可能的，因为数组中所有元素的类型必须相同，而Brass和BrassPlus是不同的类型。</p>

<p><strong>然而，可以创建指向Brass的指针数组。由于使用的是公有继承模型，因此Brass指针既可以指向Brass对象，也可以指向BrassPlus对象。</strong></p>

<p>多态真是美妙！</p>

<h3 id="静态联编和动态联编">静态联编和动态联编</h3>

<p>程序调用函数时，将使用哪个可执行代码块呢？</p>

<p><strong>编译器将源代码中的函数调用解释为执行特定的函数代码块被称为函数名联编（binding）。</strong></p>

<ul>
  <li>在编译过程中进行联编被称为静态联编（static binding），又称为早期联编（early binding）。</li>
  <li>生成能够在程序运行时选择正确的虚方法的代码，这被称为动态联编（dynamic binding），又称为晚期联编（late binding）。</li>
</ul>

<h4 id="指针引用类型的兼容">指针、引用类型的兼容</h4>

<pre><code class="language-C++">BrassPlus dilly("Annie Dill",493222,2000);
Brass* pb=&amp;dilly;
Brass&amp; pb=dilly;
</code></pre>

<p>将派生类引用或指针转换为基类引用或指针被称为<strong>向上强制转换</strong>（upcasting），这使公有继承不需要进行显式类型转换。</p>

<p>向上强制转换是可传递的，也就是说，如果从BrassPlus派生出BrassPlusPlus类，则Brass指针或引用可以引用Brass对象、BrassPlus对象或BrassPlusPlus对象。</p>

<p>相反的过程——将基类指针或引用转换为派生类指针或引用——称为向下强制转换(downcasting)。</p>

<p>如果不使用显式类型转换，则向下强制转换是不允许的。</p>

<p>通常不推荐这么做，唯一有可能的情况是：本来这个基类指针指向的就是派生类对象，再将其转换成派生类指针。</p>

<pre><code class="language-C++">class Base {
public:
    virtual ~Base() {}
};

class Derived : public Base {
public:
    void sayHello() {
        std::cout &lt;&lt; "Hello from Derived!" &lt;&lt; std::endl;
    }
};

int main() {
    Base* b = new Derived(); // Upcasting

    // Downcasting
    Derived* d = (Derived*)(b);
    if (d) { // Check if the downcasting was successful
        d-&gt;sayHello(); // Now it's safe to call
    }

    delete b;
    return 0;
}
</code></pre>

<h4 id="两种类型的联编">两种类型的联编</h4>

<ul>
  <li>为使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，所以会有额外处理开销。所以使用静态联编效率更高。</li>
  <li>如果派生类不重新定义基类的任何方法，就不需要使用动态联编。</li>
</ul>

<h4 id="虚函数的工作原理">虚函数的工作原理</h4>

<p>通常，编译器处理虚函数的方法是：给每个对象添加一个隐藏成员。</p>

<p>隐藏成员中保存了一个<strong>指向函数地址数组的指针</strong>。这种数组称为<strong>虚函数表</strong>（virtual function table, vtbl）。（究竟有多少级指针呢？）</p>

<p>虚函数表中存储了为类对象进行声明的虚函数的地址。例如，基类对象包含一个指针，该指针指向基类中所有虚函数的地址表。派生类对象将包含一个指向独立地址表的指针。</p>

<ul>
  <li>如果派生类提供了虚函数的新定义，该虚函数表将保存新函数的地址。</li>
  <li>如果派生类没有重新定义虚函数，该虚函数表将保存函数原始版本的地址。</li>
</ul>

<p>再整理一下概念：</p>

<ul>
  <li><strong>虚函数表（vtable）</strong>：当一个类中声明了虚函数，编译器会为这个类生成一个虚函数表。这个表是一个函数指针数组，数组中的每个元素都是指向类的虚函数的指针。每个类的虚函数表是唯一的，所有该类的对象都共享同一个虚函数表。</li>
  <li><strong>虚指针（vptr）</strong>：当一个类对象被创建时，如果该类中有虚函数，那么编译器会在对象内部添加一个虚指针。这个虚指针指向该类的虚函数表。如果有派生类对象，那么派生类对象的虚指针会指向派生类的虚函数表。</li>
  <li><strong>动态绑定</strong>：当我们通过基类指针或引用调用虚函数时，编译器会查找指针或引用所指向的对象的虚指针，然后通过虚指针找到对应的虚函数表，最后在虚函数表中查找并调用相应的虚函数。这个过程是在运行时进行的，因此称为动态绑定。</li>
</ul>

<p>使用虚函数时，在内存和执行速度方面有一定的成本，包括：</p>

<ul>
  <li>每个对象都将增大，增大量为存储地址的空间。</li>
  <li>对于每个类，编译器都创建一个虚函数地址表（数组）。</li>
  <li>对于每个函数调用，都需要执行一项额外的操作，即到表中查找地址。</li>
</ul>

<h4 id="有关虚函数注意事项">有关虚函数注意事项</h4>

<h5 id="构造函数">构造函数</h5>

<p>构造函数不能是虚函数。实际上，这没有意义</p>

<p>创建派生类对象时，将调用派生类的构造函数，然后派生类的构造函数会调用基类的一个构造函数。</p>

<p><strong>也就是说派生类不继承基类的构造函数。</strong></p>

<h5 id="析构函数">析构函数</h5>

<p>通常应给基类提供一个虚析构函数（这样派生类的析构函数自动也成为虚的），即使它并不需要析构函数。</p>

<p>考虑这样的场景：</p>

<pre><code class="language-C++">Employee * pe=new Singer;
...
delete pe;
</code></pre>

<ul>
  <li>如果析构函数不是虚的，那么delete只会释放基类部分的内存（会引发问题！）。</li>
  <li>如果析构函数是虚的，那么先调用派生类的析构，再自动调用基类的析构函数（这是声明周期管理的特性）。</li>
</ul>

<h5 id="友元">友元</h5>

<p>友元不能是虚函数，因为<strong>友元不是类成员，而只有成员才能是虚函数。</strong></p>

<p>如果由于这个原因引起了设计问题，可以通过让友元函数使用虚成员函数来解决。</p>

<h5 id="没有重新定义">没有重新定义</h5>

<p>如果派生类没有重新定义函数，将使用该函数的基类版本。</p>

<p>如果派生类位于派生链中，则将使用最新的虚函数版本（虚函数不是不能用！）。</p>

<p><strong>也就是说从某个类开始声明了虚函数，那么后面所有的版本无论是否重新定义，都自动成为虚函数。</strong></p>

<p>例外的情况是基类版本是隐藏的（稍后将介绍）</p>

<h5 id="重新定义将隐藏方法">重新定义将隐藏方法</h5>

<p>如果派生类中的函数和基类中的虚函数<strong>有相同的名称和参数列表</strong>，那么派生类中的函数将<strong>覆盖</strong>（也称为重写）基类中的虚函数，这是虚函数的正常使用方式。</p>

<p>如果派生类中的函数和基类中的函数具有相同的名称，但参数列表不同，那么派生类中的函数将会<strong>隐藏基类中所有同名的函数</strong>，无论参数列表是否相同。</p>

<p>如果你想在派生类中使用和基类中同名但参数列表不同的函数，而不隐藏基类中的函数，你可以使用<code class="language-plaintext highlighter-rouge">using</code>声明。</p>

<p>这引出了两条经验规则：</p>

<ul>
  <li>
    <p>如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用或指针，则可以修改为指向派生类的引用或指针。<strong>（也即：可以允许返回类型不同的重载）</strong></p>

    <p>这种允许返回类型随类类型的变化而变化的特性被称为返回类型协变（covariance of return type）。</p>
  </li>
  <li>
    <p>如果基类声明被重载了，则应在派生类中重新定义所有的基类版本。</p>
  </li>
</ul>

<h3 id="访问控制protected">访问控制：protected</h3>

<p>private和protected之间的区别只有在基类派生的类中才会表现出来。</p>

<p>派生类的成员可以直接访问基类的保护成员，但不能直接访问基类的私有成员。</p>

<p>最好对类数据成员采用私有访问控制，不要使用保护访问控制；同时通过基类方法使派生类能够访问基类数据。</p>

<h3 id="抽象基类abc">抽象基类（ABC）</h3>

<p>C++通过使用纯虚函数（pure virtual function）提供未实现的函数。纯虚函数声明的结尾处为=0，参见：</p>

<pre><code class="language-C++">class BaseEllipse
{
public:
    virtual double Area() const=0;
}
</code></pre>

<p>纯虚函数的理念是：包含纯虚函数的类只用作基类。</p>

<p><strong>当类声明中包含纯虚函数时，则不能创建该类的对象。</strong></p>

<p>这里的方法Area()没有定义，但C++甚至允许纯虚函数有定义：</p>

<pre><code class="language-C++">//myclass.h
void Move(int nx,ny)=0;

//myclass.cpp
void BaseEllipse::Move(int nx,ny){x=nx;y=ny;}
...
</code></pre>

<p>为什么不干脆直接将派生类们分开定义？因为它们还是有共同之处的，所以这种解决办法效率不高，也从逻辑上比较冗余。</p>

<h3 id="继承和动态内存分配">继承和动态内存分配</h3>

<p>假设基类使用了动态内存分配，而派生类中不使用new：</p>

<p><strong>是否需要显式定义析构函数？</strong></p>

<p>不需要。</p>

<p>派生类的默认构造函数总是要进行一些操作：执行自身的代码后调用基类析构函数。</p>

<p>由于不需要额外执行特殊操作，所以不需要显式定义，用默认析构函数就行。</p>

<p><strong>是否需要显式定义复制构造函数？</strong></p>

<p>不需要。</p>

<p>复制类成员或继承的类组件时，是使用该类的复制构造函数完成的。也就是说基类部分的复制是调用基类的复制构造函数，而派生类部分使用派生类的复制构造函数。</p>

<p>这主要是考虑了动态内存分配。基类的复制构造函数保证了深复制，而派生类没有额外new，所以自动调用默认的复制构造函数，执行浅复制就行。</p>

<p><strong>是否需要显式定义赋值运算符？</strong></p>

<p>不需要，理由同上。</p>

<hr />

<p>假设派生类中使用了new，则以上三种都要重新显式定义。</p>

<ul>
  <li>
    <p>派生类析构函数<strong>自动</strong>调用基类的析构函数，故其自身的职责是对派生类构造函数执行工作的进行清理。</p>
  </li>
  <li>
    <p>派生类的复制构造函数只能访问派生类的数据，因此它必须调用基类的复制构造函数来处理共享的基类的数据。</p>

    <p>调用派生类的复制构造函数时，会自动调用基类的默认复制构造函数，但如果需要调用的是基类的某个非默认的复制构造函数，则必须手动显式调用。</p>
  </li>
  <li>
    <p>对于赋值运算符同理。</p>
  </li>
</ul>


    </div>

</article>
<div class="post-nav"><a class="previous" href="/csnotes/2024/02/11/CH12-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.html" title="CH12 类和动态内存分配">CH12 类和动态内存分配</a><a class="next" href="/csnotes/2024/02/11/CH4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B.html" title="CH4 复合类型">CH4 复合类型</a></div><div class="post-related">
      <div>Related Articles</div>
      <ul>
        <li class="">
          <a class="post-link" href="/csnotes/2024/02/11/CH10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB.html" title="CH10 对象和类">
            CH10 对象和类<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li><li class="">
          <a class="post-link" href="/csnotes/2024/02/11/CH9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4.html" title="CH9 内存模型和名称空间">
            CH9 内存模型和名称空间<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li><li class="">
          <a class="post-link" href="/lecturenotes/2023/11/14/CH6-%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95.html" title="CH6 运算方法">
            CH6 运算方法<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li><li class="">
          <a class="post-link" href="/learning/notes/2023/11/19/%E5%A4%9A%E8%87%82%E8%80%81%E8%99%8E%E6%9C%BA%E9%97%AE%E9%A2%98.html" title="多臂老虎机问题">
            多臂老虎机问题<span class="post-badges">
  <span class="post-badge badge-top">TOP</span>
  <span class="post-badge badge-new">NEW</span>
</span>
</a>
        </li></ul>
    </div><div class="post-comments"></div></section>
</div>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

  </section>
  <section class="sidebar" style="margin-left: 15px;">
    <!-- Get sidebar items --><style type="text/css" media="screen">
.post-menu ul {
  list-style: none;
  padding: 0;
  margin: 0;
}
</style>

<div class="post-menu">
  <div class="post-menu-title">TOC</div>
  <div class="post-menu-content"></div>
</div>

<script>
  function generateContent() {
    var menu = document.querySelector(".post-menu");
    var menuContent =  menu.querySelector(".post-menu-content");
    var headings = document.querySelector(".post-content").querySelectorAll("h2, h3, h4, h5, h6");

    // Hide menu when no headings
    if (headings.length === 0) {
      return menu.style.display = "none";
    }

    // Generate post menu
    var menuHTML = '';
    for (var i = 0; i < headings.length; i++) {
      var h = headings[i];
      menuHTML += (
        '<li class="h-' + h.tagName.toLowerCase() + '">'
        + '<a href="#h-' + h.getAttribute('id') + '">' + h.textContent + '</a></li>');
    }

    menuContent.innerHTML = '<ul>' + menuHTML + '</ul>';

    // The header element
    var header = document.querySelector('header.site-header');

    function doMenuCollapse(index, over_items) {
      var items = menuContent.firstChild.children;

      if (over_items == undefined) {
        over_items = 20;
      }

      if (items.length < over_items) {
        return;
      }

      var activeItem = items[index];
      var beginItem = activeItem
      var endItem = activeItem
      var beginIndex = index;
      var endIndex = index + 1;
      while (beginIndex >= 0
        && !items[beginIndex].classList.contains('h-h2')) {
        beginIndex -= 1;
      }
      while (endIndex < items.length
        && !items[endIndex].classList.contains('h-h2')) {
        endIndex += 1;
      }
      for (var i = 0; i < beginIndex; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
      for (var i = beginIndex + 1; i < endIndex; i++) {
        item = items[i]
        // if (!item.classList.contains('h-h2')) {
          item.style.display = '';
        // }
      }
      for (var i = endIndex; i < items.length; i++) {
        item = items[i]
        if (!item.classList.contains('h-h2')) {
          item.style.display = 'none';
        }
      }
    }

    // Init menu collapsed
    doMenuCollapse(-1);

    // Active the menu item
    window.addEventListener('scroll', function (event) {
      var lastActive = menuContent.querySelector('.active');
      var changed = true;
      var activeIndex = -1;
      for (var i = headings.length - 1; i >= 0; i--) {
        var h = headings[i];
        var headingRect = h.getBoundingClientRect();
        var headerRect = header.getBoundingClientRect();
        var headerTop = Math.floor(headerRect.top);
        var headerHeight = Math.floor(headerRect.height);
        var headerHeight = headerTop + headerHeight + 20;
        if (headingRect.top <= headerHeight) {
          var id = 'h-' + h.getAttribute('id');
          var a = menuContent.querySelector('a[href="#' + id  + '"]');
          var curActive = a.parentNode;
          if (curActive) {
            curActive.classList.add('active');
            activeIndex = i;
          }
          if (lastActive == curActive) {
            changed = false;
          }
          break;
        }
      }
      if (changed) {
        if (lastActive) {
          lastActive.classList.remove('active');
        }
        doMenuCollapse(activeIndex);
      }
      event.preventDefault();
    });
  }
  generateContent();
</script>
</section>
</div>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">
    <div class="site-footer-inner"><div>Unpublished Work <span class="copyleft">&copy;</span> 2017-2024 DragonK</div>
      <div>Powered by <a title="Jekyll is a simple, blog-aware, static site
      generator." href="https://jekyllrb.com/">Jekyll</a> &amp; <a title="Yat, yet
      another theme." href="https://github.com/jeffreytse/jekyll-theme-yat">Yat Theme</a>.</div>
      <div class="footer-col rss-subscribe">Subscribe <a href="/feed.xml">via RSS</a></div>
    </div>
  </div>
</footer>
</body>
</html>
